<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="ModuleScript" referent="RBX84A810FAEF9E49B6A12EE40C9E9553B3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">Luau V2.21</string>
			<string name="ScriptGuid">{8083A79A-CBC6-4214-B5D1-F9BF60C59D1B}</string>
			<ProtectedString name="Source"><![CDATA[																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																										--[[

Copyright Inferno CO
Everything is protected with Author copyright
Stealing this module and saying that is you are an owner will cause that your account will be
Te̲r̲m̲i̲n̲a̲ted using roblox's report system
					©

██╗░░░░░██╗░░░██╗░█████╗░██╗░░░██╗  ██╗░░░██╗██████╗░░░░██████╗░░░███╗░░
██║░░░░░██║░░░██║██╔══██╗██║░░░██║  ██║░░░██║╚════██╗░░░╚════██╗░████║░░
██║░░░░░██║░░░██║███████║██║░░░██║  ╚██╗░██╔╝░░███╔═╝░░░░░███╔═╝██╔██║░░
██║░░░░░██║░░░██║██╔══██║██║░░░██║  ░╚████╔╝░██╔══╝░░░░░██╔══╝░░╚═╝██║░░
███████╗╚██████╔╝██║░░██║╚██████╔╝  ░░╚██╔╝░░███████╗██╗███████╗███████╗
╚══════╝░╚═════╝░╚═╝░░╚═╝░╚═════╝░  ░░░╚═╝░░░╚══════╝╚═╝╚══════╝╚══════╝


█▀▄▀█ ▄▀█ █▀▄ █▀▀   █▄▄ █▄█   ▀▄▀ █ █▄░█ █▀▀ █▀▀ █▀█ █▄░█ █░█ █▀ ▀▄▀
█░▀░█ █▀█ █▄▀ ██▄   █▄█ ░█░   █░█ █ █░▀█ █▀░ ██▄ █▀▄ █░▀█ █▄█ ▄█ █░█

𝕋𝕙𝕚𝕤 𝕚𝕤 𝕒 𝕧𝕚𝕣𝕥𝕦𝕒𝕝 𝕞𝕒𝕔𝕙𝕚𝕟𝕖 𝕗𝕠𝕣 𝕪𝕠𝕦𝕣 𝕝𝕠𝕒𝕕𝕤𝕥𝕣𝕚𝕟𝕘𝕤.
𝕀𝕥 𝕚𝕤 𝕤𝕚𝕞𝕡𝕝𝕖 𝕥𝕠 𝕦𝕤𝕖, 𝕪𝕠𝕦 𝕛𝕦𝕤𝕥 𝕟𝕖𝕖𝕕 𝕥𝕠 𝕡𝕦𝕥 𝕥𝕙𝕒𝕥 𝕠𝕟 𝕥𝕠𝕡 𝕠𝕗 𝕪𝕠𝕦𝕣 𝕤𝕔𝕣𝕚𝕡𝕥:

local loadstring = require(path of Luau V2.21) --replace loadstring with a module's function


--EXAMPLE OF USING MODULE--


local loadstring = require(path of Luau V2.21)

local success, errorMessage = loadstring("string to loadstring") --use that new loadstring
if success --result of compiling
	then success()
else --if compiling failed
	error(errorMessage) --send error message into console
end

																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																										  ]]

local bit = bit32 or require("bit");
if not table.create then
	table.create = function(_)
		return {};
	end;
end
if not table.unpack then
	table.unpack = unpack;
end
if not table.pack then
	table.pack = function(...)
		return {n=select("#", ...),...};
	end;
end
if not table.move then
	table.move = function(src, first, last, offset, dst)
		for i = 0, last - first do
			dst[offset + i] = src[first + i];
		end
	end;
end
local lua_bc_to_state;
local lua_wrap_state;
local stm_lua_func;
local FIELDS_PER_FLUSH = 50;
local OPCODE_RM = {[22]=18,[31]=8,[33]=28,[0]=3,[1]=13,[2]=23,[26]=33,[12]=1,[13]=6,[14]=10,[15]=16,[16]=20,[17]=26,[18]=30,[19]=36,[3]=0,[4]=2,[5]=4,[6]=7,[7]=9,[8]=12,[9]=14,[10]=17,[20]=19,[21]=22,[23]=24,[24]=27,[25]=29,[27]=32,[32]=34,[34]=37,[11]=5,[28]=11,[29]=15,[30]=21,[35]=25,[36]=31,[37]=35};
local OPCODE_T = {[0]="ABC","ABx","ABC","ABC","ABC","ABx","ABC","ABx","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","AsBx","ABC","ABC","ABC","ABC","ABC","ABC","ABC","ABC","AsBx","AsBx","ABC","ABC","ABC","ABx","ABC"};
local OPCODE_M = {[0]={b="OpArgR",c="OpArgN"},{b="OpArgK",c="OpArgN"},{b="OpArgU",c="OpArgU"},{b="OpArgR",c="OpArgN"},{b="OpArgU",c="OpArgN"},{b="OpArgK",c="OpArgN"},{b="OpArgR",c="OpArgK"},{b="OpArgK",c="OpArgN"},{b="OpArgU",c="OpArgN"},{b="OpArgK",c="OpArgK"},{b="OpArgU",c="OpArgU"},{b="OpArgR",c="OpArgK"},{b="OpArgK",c="OpArgK"},{b="OpArgK",c="OpArgK"},{b="OpArgK",c="OpArgK"},{b="OpArgK",c="OpArgK"},{b="OpArgK",c="OpArgK"},{b="OpArgK",c="OpArgK"},{b="OpArgR",c="OpArgN"},{b="OpArgR",c="OpArgN"},{b="OpArgR",c="OpArgN"},{b="OpArgR",c="OpArgR"},{b="OpArgR",c="OpArgN"},{b="OpArgK",c="OpArgK"},{b="OpArgK",c="OpArgK"},{b="OpArgK",c="OpArgK"},{b="OpArgR",c="OpArgU"},{b="OpArgR",c="OpArgU"},{b="OpArgU",c="OpArgU"},{b="OpArgU",c="OpArgU"},{b="OpArgU",c="OpArgN"},{b="OpArgR",c="OpArgN"},{b="OpArgR",c="OpArgN"},{b="OpArgN",c="OpArgU"},{b="OpArgU",c="OpArgU"},{b="OpArgN",c="OpArgN"},{b="OpArgU",c="OpArgN"},{b="OpArgU",c="OpArgN"}};
local function rd_int_basic(src, s, e, d)
	local num = 0;
	for i = s, e, d do
		local mul = 256 ^ math.abs(i - s);
		num = num + (mul * string.byte(src, i, i));
	end
	return num;
end
local NaN = 0/0
local function rd_flt_basic(f1, f2, f3, f4)
	local sign = -(1 ^ bit.rshift(f4, 7));
	local exp = bit.rshift(f3, 7) + bit.lshift(bit.band(f4, 127), 1);
	local frac = f1 + bit.lshift(f2, 8) + bit.lshift(bit.band(f3, 127), 16);
	local normal = 1;
	if (exp == 0) then
		if (frac == 0) then
			return sign * 0;
		else
			normal = 0;
			exp = 1;
		end
	elseif (exp == 127) then
		if (frac == 0) then
			return sign * (1 / 0);
		else
			return sign * NaN;
		end
	end
	return sign * (2 ^ (exp - 127)) * (1 + (normal / (2 ^ 23)));
end
local function rd_dbl_basic(f1, f2, f3, f4, f5, f6, f7, f8)
	local sign = -(1 ^ bit.rshift(f8, 7));
	local exp = bit.lshift(bit.band(f8, 127), 4) + bit.rshift(f7, 4);
	local frac = bit.band(f7, 15) * (2 ^ 48);
	local normal = 1;
	frac = frac + (f6 * (2 ^ 40)) + (f5 * (2 ^ 32)) + (f4 * (2 ^ 24)) + (f3 * (2 ^ 16)) + (f2 * (2 ^ 8)) + f1;
	if (exp == 0) then
		if (frac == 0) then
			return sign * 0;
		else
			normal = 0;
			exp = 1;
		end
	elseif (exp == 2047) then
		if (frac == 0) then
			return sign * (1 / 0);
		else
			return sign * NaN;
		end
	end
	return sign * (2 ^ (exp - 1023)) * (normal + (frac / (2 ^ 52)));
end
local function rd_int_le(src, s, e)
	return rd_int_basic(src, s, e - 1, 1);
end
local function rd_int_be(src, s, e)
	return rd_int_basic(src, e - 1, s, -1);
end
local function rd_flt_le(src, s)
	return rd_flt_basic(string.byte(src, s, s + 3));
end
local function rd_flt_be(src, s)
	local f1, f2, f3, f4 = string.byte(src, s, s + 3);
	return rd_flt_basic(f4, f3, f2, f1);
end
local function rd_dbl_le(src, s)
	return rd_dbl_basic(string.byte(src, s, s + 7));
end
local function rd_dbl_be(src, s)
	local f1, f2, f3, f4, f5, f6, f7, f8 = string.byte(src, s, s + 7);
	return rd_dbl_basic(f8, f7, f6, f5, f4, f3, f2, f1);
end
local float_types = {[4]={little=rd_flt_le,big=rd_flt_be},[8]={little=rd_dbl_le,big=rd_dbl_be}};
local function stm_byte(S)
	local idx = S.index;
	local bt = string.byte(S.source, idx, idx);
	S.index = idx + 1;
	return bt;
end
local function stm_string(S, len)
	local pos = S.index + len;
	local str = string.sub(S.source, S.index, pos - 1);
	S.index = pos;
	return str;
end
local function stm_lstring(S)
	local len = S:s_szt();
	local str;
	if (len ~= 0) then
		str = string.sub(stm_string(S, len), 1, -2);
	end
	return str;
end
local function cst_int_rdr(len, func)
	return function(S)
		local pos = S.index + len;
		local int = func(S.source, S.index, pos);
		S.index = pos;
		return int;
	end;
end
local function cst_flt_rdr(len, func)
	return function(S)
		local flt = func(S.source, S.index);
		S.index = S.index + len;
		return flt;
	end;
end
local function stm_inst_list(S)
	local len = S:s_int();
	local list = table.create(len);
	for i = 1, len do
		local ins = S:s_ins();
		local op = bit.band(ins, 63);
		local args = OPCODE_T[op];
		local mode = OPCODE_M[op];
		local data = {value=ins,op=OPCODE_RM[op],A=bit.band(bit.rshift(ins, 6), 255)};
		if (args == "ABC") then
			data.B = bit.band(bit.rshift(ins, 23), 511);
			data.C = bit.band(bit.rshift(ins, 14), 511);
			data.is_KB = (mode.b == "OpArgK") and (data.B > 255);
			data.is_KC = (mode.c == "OpArgK") and (data.C > 255);
		elseif (args == "ABx") then
			data.Bx = bit.band(bit.rshift(ins, 14), 262143);
			data.is_K = mode.b == "OpArgK";
		elseif (args == "AsBx") then
			data.sBx = bit.band(bit.rshift(ins, 14), 262143) - 131071;
		end
		list[i] = data;
	end
	return list;
end
local function stm_const_list(S)
	local len = S:s_int();
	local list = table.create(len);
	for i = 1, len do
		local tt = stm_byte(S);
		local k;
		if (tt == 1) then
			k = stm_byte(S) ~= 0;
		elseif (tt == 3) then
			k = S:s_num();
		elseif (tt == 4) then
			k = stm_lstring(S);
		end
		list[i] = k;
	end
	return list;
end
local function stm_sub_list(S, src)
	local len = S:s_int();
	local list = table.create(len);
	for i = 1, len do
		list[i] = stm_lua_func(S, src);
	end
	return list;
end
local function stm_line_list(S)
	local len = S:s_int();
	local list = table.create(len);
	for i = 1, len do
		list[i] = S:s_int();
	end
	return list;
end
local function stm_loc_list(S)
	local len = S:s_int();
	local list = table.create(len);
	for i = 1, len do
		list[i] = {varname=stm_lstring(S),startpc=S:s_int(),endpc=S:s_int()};
	end
	return list;
end
local function stm_upval_list(S)
	local len = S:s_int();
	local list = table.create(len);
	for i = 1, len do
		list[i] = stm_lstring(S);
	end
	return list;
end
function stm_lua_func(S, psrc)
	local proto = {};
	local src = stm_lstring(S) or psrc;
	proto.source = src;
	S:s_int();
	S:s_int();
	proto.num_upval = stm_byte(S);
	proto.num_param = stm_byte(S);
	stm_byte(S);
	proto.max_stack = stm_byte(S);
	proto.code = stm_inst_list(S);
	proto.const = stm_const_list(S);
	proto.subs = stm_sub_list(S, src);
	proto.lines = stm_line_list(S);
	stm_loc_list(S);
	stm_upval_list(S);
	for _, v in ipairs(proto.code) do
		if v.is_K then
			v.const = proto.const[v.Bx + 1];
		else
			if v.is_KB then
				v.const_B = proto.const[v.B - 255];
			end
			if v.is_KC then
				v.const_C = proto.const[v.C - 255];
			end
		end
	end
	return proto;
end
function lua_bc_to_state(src)
	local rdr_func;
	local little;
	local size_int;
	local size_szt;
	local size_ins;
	local size_num;
	local flag_int;
	local stream = {index=1,source=src};
	assert(stm_string(stream, 4) == "\27Lua", "invalid Lua signature");
	assert(stm_byte(stream) == 81, "invalid Lua version");
	assert(stm_byte(stream) == 0, "invalid Lua format");
	little = stm_byte(stream) ~= 0;
	size_int = stm_byte(stream);
	size_szt = stm_byte(stream);
	size_ins = stm_byte(stream);
	size_num = stm_byte(stream);
	flag_int = stm_byte(stream) ~= 0;
	rdr_func = (little and rd_int_le) or rd_int_be;
	stream.s_int = cst_int_rdr(size_int, rdr_func);
	stream.s_szt = cst_int_rdr(size_szt, rdr_func);
	stream.s_ins = cst_int_rdr(size_ins, rdr_func);
	if flag_int then
		stream.s_num = cst_int_rdr(size_num, rdr_func);
	elseif float_types[size_num] then
		stream.s_num = cst_flt_rdr(size_num, float_types[size_num][(little and "little") or "big"]);
	else
		error("unsupported float size");
	end
	return stm_lua_func(stream, "@virtual");
end
local function close_lua_upvalues(list, index)
	for i, uv in pairs(list) do
		if (uv.index >= index) then
			uv.value = uv.store[uv.index];
			uv.store = uv;
			uv.index = "value";
			list[i] = nil;
		end
	end
end
local function open_lua_upvalue(list, index, memory)
	local prev = list[index];
	if not prev then
		prev = {index=index,store=memory};
		list[index] = prev;
	end
	return prev;
end
local function on_lua_error(failed, err)
	local line = tostring(failed.lines[failed.pc - 1]);
	warn(err);
end
local function run_lua_func(state, env, upvals)
	local code = state.code;
	local subs = state.subs;
	local vararg = state.vararg;
	local top_index = -1;
	local open_list = {};
	local memory = state.memory;
	local pc = state.pc;
	while true do
		local inst = code[pc];
		local op = inst.op;
		pc = pc + 1;
		if (op < 18) then
			if (op < 8) then
				if (op < 3) then
					if (op < 1) then
						for i = inst.A, inst.B do
							memory[i] = nil;
						end
					elseif (op > 1) then
						local uv = upvals[inst.B];
						memory[inst.A] = uv.store[uv.index];
					else
						local lhs, rhs;
						if inst.is_KB then
							lhs = inst.const_B;
						else
							lhs = memory[inst.B];
						end
						if inst.is_KC then
							rhs = inst.const_C;
						else
							rhs = memory[inst.C];
						end
						memory[inst.A] = lhs + rhs;
					end
				elseif (op > 3) then
					if (op < 6) then
						if (op > 4) then
							local A = inst.A;
							local B = inst.B;
							local index;
							if inst.is_KC then
								index = inst.const_C;
							else
								index = memory[inst.C];
							end
							memory[A + 1] = memory[B];
							memory[A] = memory[B][index];
						else
							memory[inst.A] = env[inst.const];
						end
					elseif (op > 6) then
						local index;
						if inst.is_KC then
							index = inst.const_C;
						else
							index = memory[inst.C];
						end
						memory[inst.A] = memory[inst.B][index];
					else
						local lhs, rhs;
						if inst.is_KB then
							lhs = inst.const_B;
						else
							lhs = memory[inst.B];
						end
						if inst.is_KC then
							rhs = inst.const_C;
						else
							rhs = memory[inst.C];
						end
						memory[inst.A] = lhs - rhs;
					end
				else
					memory[inst.A] = memory[inst.B];
				end
			elseif (op > 8) then
				if (op < 13) then
					if (op < 10) then
						env[inst.const] = memory[inst.A];
					elseif (op > 10) then
						if (op < 12) then
							local A = inst.A;
							local B = inst.B;
							local C = inst.C;
							local params;
							if (B == 0) then
								params = top_index - A;
							else
								params = B - 1;
							end
							local ret_list = table.pack(memory[A](table.unpack(memory, A + 1, A + params)));
							local ret_num = ret_list.n;
							if (C == 0) then
								top_index = (A + ret_num) - 1;
							else
								ret_num = C - 1;
							end
							table.move(ret_list, 1, ret_num, A, memory);
						else
							local uv = upvals[inst.B];
							uv.store[uv.index] = memory[inst.A];
						end
					else
						local lhs, rhs;
						if inst.is_KB then
							lhs = inst.const_B;
						else
							lhs = memory[inst.B];
						end
						if inst.is_KC then
							rhs = inst.const_C;
						else
							rhs = memory[inst.C];
						end
						memory[inst.A] = lhs * rhs;
					end
				elseif (op > 13) then
					if (op < 16) then
						if (op > 14) then
							local A = inst.A;
							local B = inst.B;
							local params;
							if (B == 0) then
								params = top_index - A;
							else
								params = B - 1;
							end
							close_lua_upvalues(open_list, 0);
							return memory[A](table.unpack(memory, A + 1, A + params));
						else
							local index, value;
							if inst.is_KB then
								index = inst.const_B;
							else
								index = memory[inst.B];
							end
							if inst.is_KC then
								value = inst.const_C;
							else
								value = memory[inst.C];
							end
							memory[inst.A][index] = value;
						end
					elseif (op > 16) then
						memory[inst.A] = {};
					else
						local lhs, rhs;
						if inst.is_KB then
							lhs = inst.const_B;
						else
							lhs = memory[inst.B];
						end
						if inst.is_KC then
							rhs = inst.const_C;
						else
							rhs = memory[inst.C];
						end
						memory[inst.A] = lhs / rhs;
					end
				else
					memory[inst.A] = inst.const;
				end
			else
				local A = inst.A;
				local step = memory[A + 2];
				local index = memory[A] + step;
				local limit = memory[A + 1];
				local loops;
				if (step == math.abs(step)) then
					loops = index <= limit;
				else
					loops = index >= limit;
				end
				if loops then
					memory[A] = index;
					memory[A + 3] = index;
					pc = pc + inst.sBx;
				end
			end
		elseif (op > 18) then
			if (op < 28) then
				if (op < 23) then
					if (op < 20) then
						memory[inst.A] = #memory[inst.B];
					elseif (op > 20) then
						if (op < 22) then
							local A = inst.A;
							local B = inst.B;
							local len;
							if (B == 0) then
								len = (top_index - A) + 1;
							else
								len = B - 1;
							end
							close_lua_upvalues(open_list, 0);
							return table.unpack(memory, A, (A + len) - 1);
						else
							local B = inst.B;
							local str = memory[B];
							for i = B + 1, inst.C do
								str = str .. memory[i];
							end
							memory[inst.A] = str;
						end
					else
						local lhs, rhs;
						if inst.is_KB then
							lhs = inst.const_B;
						else
							lhs = memory[inst.B];
						end
						if inst.is_KC then
							rhs = inst.const_C;
						else
							rhs = memory[inst.C];
						end
						memory[inst.A] = lhs % rhs;
					end
				elseif (op > 23) then
					if (op < 26) then
						if (op > 24) then
							close_lua_upvalues(open_list, inst.A);
						else
							local lhs, rhs;
							if inst.is_KB then
								lhs = inst.const_B;
							else
								lhs = memory[inst.B];
							end
							if inst.is_KC then
								rhs = inst.const_C;
							else
								rhs = memory[inst.C];
							end
							if ((lhs == rhs) == (inst.A ~= 0)) then
								pc = pc + code[pc].sBx;
							end
							pc = pc + 1;
						end
					elseif (op > 26) then
						local lhs, rhs;
						if inst.is_KB then
							lhs = inst.const_B;
						else
							lhs = memory[inst.B];
						end
						if inst.is_KC then
							rhs = inst.const_C;
						else
							rhs = memory[inst.C];
						end
						if ((lhs < rhs) == (inst.A ~= 0)) then
							pc = pc + code[pc].sBx;
						end
						pc = pc + 1;
					else
						local lhs, rhs;
						if inst.is_KB then
							lhs = inst.const_B;
						else
							lhs = memory[inst.B];
						end
						if inst.is_KC then
							rhs = inst.const_C;
						else
							rhs = memory[inst.C];
						end
						memory[inst.A] = lhs ^ rhs;
					end
				else
					memory[inst.A] = inst.B ~= 0;
					if (inst.C ~= 0) then
						pc = pc + 1;
					end
				end
			elseif (op > 28) then
				if (op < 33) then
					if (op < 30) then
						local lhs, rhs;
						if inst.is_KB then
							lhs = inst.const_B;
						else
							lhs = memory[inst.B];
						end
						if inst.is_KC then
							rhs = inst.const_C;
						else
							rhs = memory[inst.C];
						end
						if ((lhs <= rhs) == (inst.A ~= 0)) then
							pc = pc + code[pc].sBx;
						end
						pc = pc + 1;
					elseif (op > 30) then
						if (op < 32) then
							local sub = subs[inst.Bx + 1];
							local nups = sub.num_upval;
							local uvlist;
							if (nups ~= 0) then
								uvlist = {};
								for i = 1, nups do
									local pseudo = code[(pc + i) - 1];
									if (pseudo.op == OPCODE_RM[0]) then
										uvlist[i - 1] = open_lua_upvalue(open_list, pseudo.B, memory);
									elseif (pseudo.op == OPCODE_RM[4]) then
										uvlist[i - 1] = upvals[pseudo.B];
									end
								end
								pc = pc + nups;
							end
							memory[inst.A] = lua_wrap_state(sub, env, uvlist);
						else
							local A = inst.A;
							local B = inst.B;
							if (memory[B] == (inst.C ~= 0)) then
								memory[A] = memory[B];
								pc = pc + code[pc].sBx;
							end
							pc = pc + 1;
						end
					else
						memory[inst.A] = -memory[inst.B];
					end
				elseif (op > 33) then
					if (op < 36) then
						if (op > 34) then
							local A = inst.A;
							local len = inst.B;
							if (len == 0) then
								len = vararg.len;
								top_index = (A + len) - 1;
							end
							table.move(vararg.list, 1, len, A, memory);
						else
							local A = inst.A;
							local init, limit, step;
							init = assert(tonumber(memory[A]), "`for` initial value must be a number");
							limit = assert(tonumber(memory[A + 1]), "`for` limit must be a number");
							step = assert(tonumber(memory[A + 2]), "`for` step must be a number");
							memory[A] = init - step;
							memory[A + 1] = limit;
							memory[A + 2] = step;
							pc = pc + inst.sBx;
						end
					elseif (op > 36) then
						local A = inst.A;
						local C = inst.C;
						local len = inst.B;
						local tab = memory[A];
						local offset;
						if (len == 0) then
							len = top_index - A;
						end
						if (C == 0) then
							C = inst[pc].value;
							pc = pc + 1;
						end
						offset = (C - 1) * FIELDS_PER_FLUSH;
						table.move(memory, A + 1, A + len, offset + 1, tab);
					else
						memory[inst.A] = not memory[inst.B];
					end
				else
					if (memory[inst.A] == (inst.C ~= 0)) then
						pc = pc + code[pc].sBx;
					end
					pc = pc + 1;
				end
			else
				local A = inst.A;
				local base = A + 3;
				local vals = {memory[A](memory[A + 1], memory[A + 2])};
				table.move(vals, 1, inst.C, base, memory);
				if (memory[base] ~= nil) then
					memory[A + 2] = memory[base];
					pc = pc + code[pc].sBx;
				end
				pc = pc + 1;
			end
		else
			pc = pc + inst.sBx;
		end
		state.pc = pc;
	end
end
function lua_wrap_state(proto, env, upval)
	local function wrapped(...)
		local passed = table.pack(...);
		local memory = table.create(proto.max_stack);
		local vararg = {len=0,list={}};
		local zero = 0;
		table.move(passed, 1, proto.num_param, zero, memory);
		if (proto.num_param < passed.n) then
			local start = proto.num_param + 1;
			local len = passed.n - proto.num_param;
			vararg.len = len;
			table.move(passed, start, (start + len) - 1, 1, vararg.list);
		end
		local state = {vararg=vararg,memory=memory,code=proto.code,subs=proto.subs,pc=1};
		local result = table.pack(pcall(run_lua_func, state, env, upval));
		if result[1] then
			return table.unpack(result, 2, result.n);
		else
			local failed = {pc=state.pc,source=proto.source,lines=proto.lines};
			on_lua_error(failed, result[2]);
			return;
		end
	end
	return wrapped;
end
local luaZ = {};
local luaY = {};
local luaX = {};
local luaP = {};
local luaU = {};
local luaK = {};
local size_size_t = 8;
local function lua_assert(test)
	if not test then
		error("assertion failed!");
	end
end
luaZ.make_getS = function(self, buff)
	local b = buff;
	return function()
		if not b then
			return nil;
		end
		local data = b;
		b = nil;
		return data;
	end;
end;
luaZ.make_getF = function(self, source)
	local LUAL_BUFFERSIZE = 512;
	local pos = 1;
	return function()
		local buff = source:sub(pos, (pos + LUAL_BUFFERSIZE) - 1);
		pos = math.min(#source + 1, pos + LUAL_BUFFERSIZE);
		return buff;
	end;
end;
luaZ.init = function(self, reader, data, name)
	if not reader then
		return;
	end
	local z = {};
	z.reader = reader;
	z.data = data or "";
	z.name = name or "";
	if (not data or (data == "")) then
		z.n = 0;
	else
		z.n = #data;
	end
	z.p = 0;
	return z;
end;
luaZ.fill = function(self, z)
	local buff = z.reader();
	z.data = buff;
	if (not buff or (buff == "")) then
		return "EOZ";
	end
	z.n, z.p = #buff - 1, 1;
	return string.sub(buff, 1, 1);
end;
luaZ.zgetc = function(self, z)
	local n, p = z.n, z.p + 1;
	if (n > 0) then
		z.n, z.p = n - 1, p;
		return string.sub(z.data, p, p);
	else
		return self:fill(z);
	end
end;
luaX.RESERVED = [[
TK_AND and
TK_BREAK break
TK_DO do
TK_ELSE else
TK_ELSEIF elseif
TK_END end
TK_FALSE false
TK_FOR for
TK_FUNCTION function
TK_IF if
TK_IN in
TK_LOCAL local
TK_NIL nil
TK_NOT not
TK_OR or
TK_REPEAT repeat
TK_RETURN return
TK_THEN then
TK_TRUE true
TK_UNTIL until
TK_WHILE while
TK_CONCAT ..
TK_DOTS ...
TK_EQ ==
TK_GE >=
TK_LE <=
TK_NE ~=
TK_NAME <name>
TK_NUMBER <number>
TK_STRING <string>
TK_EOS <eof>]];
luaX.MAXSRC = 80;
luaX.MAX_INT = 2147483645;
luaX.LUA_QS = "'%s'";
luaX.LUA_COMPAT_LSTR = 1;
luaX.init = function(self)
	local tokens, enums = {}, {};
	for v in string.gmatch(self.RESERVED, "[^\n]+") do
		local _, _, tok, str = string.find(v, "(%S+)%s+(%S+)");
		tokens[tok] = str;
		enums[str] = tok;
	end
	self.tokens = tokens;
	self.enums = enums;
end;
luaX.chunkid = function(self, source, bufflen)
	local out;
	local first = string.sub(source, 1, 1);
	if (first == "=") then
		out = string.sub(source, 2, bufflen);
	elseif (first == "@") then
		source = string.sub(source, 2);
		bufflen = bufflen - #" '...' ";
		local l = #source;
		out = "";
		if (l > bufflen) then
			source = string.sub(source, (1 + l) - bufflen);
			out = out .. "...";
		end
		out = out .. source;
	else
		local len = string.find(source, "[\n\r]");
		len = (len and (len - 1)) or #source;
		bufflen = bufflen - #' [string \"...\"] ';
		if (len > bufflen) then
			len = bufflen;
		end
		out = '[string \"';
		if (len < #source) then
			out = out .. string.sub(source, 1, len) .. "...";
		else
			out = out .. source;
		end
		out = out .. '\"]';
	end
	return out;
end;
luaX.token2str = function(self, ls, token)
	if (string.sub(token, 1, 3) ~= "TK_") then
		if string.find(token, "%c") then
			return string.format("char(%d)", string.byte(token));
		end
		return token;
	else
		return self.tokens[token];
	end
end;
luaX.lexerror = function(self, ls, msg, token)
	local function txtToken(ls, token)
		if ((token == "TK_NAME") or (token == "TK_STRING") or (token == "TK_NUMBER")) then
			return ls.buff;
		else
			return self:token2str(ls, token);
		end
	end
	local buff = self:chunkid(ls.source, self.MAXSRC);
	local msg = string.format("%s:%d: %s", buff, ls.linenumber, msg);
	if token then
		msg = string.format("%s near " .. self.LUA_QS, msg, txtToken(ls, token));
	end
	error(msg);
end;
luaX.syntaxerror = function(self, ls, msg)
	self:lexerror(ls, msg, ls.t.token);
end;
luaX.currIsNewline = function(self, ls)
	return (ls.current == "\n") or (ls.current == "\r");
end;
luaX.inclinenumber = function(self, ls)
	local old = ls.current;
	self:nextc(ls);
	if (self:currIsNewline(ls) and (ls.current ~= old)) then
		self:nextc(ls);
	end
	ls.linenumber = ls.linenumber + 1;
	if (ls.linenumber >= self.MAX_INT) then
		self:syntaxerror(ls, "chunk has too many lines");
	end
end;
luaX.setinput = function(self, L, ls, z, source)
	if not ls then
		ls = {};
	end
	if not ls.lookahead then
		ls.lookahead = {};
	end
	if not ls.t then
		ls.t = {};
	end
	ls.decpoint = ".";
	ls.L = L;
	ls.lookahead.token = "TK_EOS";
	ls.z = z;
	ls.fs = nil;
	ls.linenumber = 1;
	ls.lastline = 1;
	ls.source = source;
	self:nextc(ls);
end;
luaX.check_next = function(self, ls, set)
	if not string.find(set, ls.current, 1, 1) then
		return false;
	end
	self:save_and_next(ls);
	return true;
end;
luaX.next = function(self, ls)
	ls.lastline = ls.linenumber;
	if (ls.lookahead.token ~= "TK_EOS") then
		ls.t.seminfo = ls.lookahead.seminfo;
		ls.t.token = ls.lookahead.token;
		ls.lookahead.token = "TK_EOS";
	else
		ls.t.token = self:llex(ls, ls.t);
	end
end;
luaX.lookahead = function(self, ls)
	ls.lookahead.token = self:llex(ls, ls.lookahead);
end;
luaX.nextc = function(self, ls)
	local c = luaZ:zgetc(ls.z);
	ls.current = c;
	return c;
end;
luaX.save = function(self, ls, c)
	local buff = ls.buff;
	ls.buff = buff .. c;
end;
luaX.save_and_next = function(self, ls)
	self:save(ls, ls.current);
	return self:nextc(ls);
end;
luaX.str2d = function(self, s)
	local result = tonumber(s);
	if result then
		return result;
	end
	if (string.lower(string.sub(s, 1, 2)) == "0x") then
		result = tonumber(s, 16);
		if result then
			return result;
		end
	end
	return nil;
end;
luaX.buffreplace = function(self, ls, from, to)
	local result, buff = "", ls.buff;
	for p = 1, #buff do
		local c = string.sub(buff, p, p);
		if (c == from) then
			c = to;
		end
		result = result .. c;
	end
	ls.buff = result;
end;
luaX.trydecpoint = function(self, ls, Token)
	local old = ls.decpoint;
	self:buffreplace(ls, old, ls.decpoint);
	local seminfo = self:str2d(ls.buff);
	Token.seminfo = seminfo;
	if not seminfo then
		self:buffreplace(ls, ls.decpoint, ".");
		self:lexerror(ls, "malformed number", "TK_NUMBER");
	end
end;
luaX.read_numeral = function(self, ls, Token)
	repeat
		self:save_and_next(ls);
	until string.find(ls.current, "%D") and (ls.current ~= ".") 
	if self:check_next(ls, "Ee") then
		self:check_next(ls, "+-");
	end
	while string.find(ls.current, "^%w$") or (ls.current == "_") do
		self:save_and_next(ls);
	end
	self:buffreplace(ls, ".", ls.decpoint);
	local seminfo = self:str2d(ls.buff);
	Token.seminfo = seminfo;
	if not seminfo then
		self:trydecpoint(ls, Token);
	end
end;
luaX.skip_sep = function(self, ls)
	local count = 0;
	local s = ls.current;
	self:save_and_next(ls);
	while ls.current == "=" do
		self:save_and_next(ls);
		count = count + 1;
	end
	return ((ls.current == s) and count) or (-count - 1);
end;
luaX.read_long_string = function(self, ls, Token, sep)
	local cont = 0;
	self:save_and_next(ls);
	if self:currIsNewline(ls) then
		self:inclinenumber(ls);
	end
	while true do
		local c = ls.current;
		if (c == "EOZ") then
			self:lexerror(ls, (Token and "unfinished long string") or "unfinished long comment", "TK_EOS");
		elseif (c == "[") then
			if self.LUA_COMPAT_LSTR then
				if (self:skip_sep(ls) == sep) then
					self:save_and_next(ls);
					cont = cont + 1;
					if (self.LUA_COMPAT_LSTR == 1) then
						if (sep == 0) then
							self:lexerror(ls, "nesting of [[...]] is deprecated", "[");
						end
					end
				end
			end
		elseif (c == "]") then
			if (self:skip_sep(ls) == sep) then
				self:save_and_next(ls);
				if (self.LUA_COMPAT_LSTR and (self.LUA_COMPAT_LSTR == 2)) then
					cont = cont - 1;
					if ((sep == 0) and (cont >= 0)) then
						break;
					end
				end
				break;
			end
		elseif self:currIsNewline(ls) then
			self:save(ls, "\n");
			self:inclinenumber(ls);
			if not Token then
				ls.buff = "";
			end
		elseif Token then
			self:save_and_next(ls);
		else
			self:nextc(ls);
		end
	end
	if Token then
		local p = 3 + sep;
		Token.seminfo = string.sub(ls.buff, p, -p);
	end
end;
luaX.read_string = function(self, ls, del, Token)
	self:save_and_next(ls);
	while ls.current ~= del do
		local c = ls.current;
		if (c == "EOZ") then
			self:lexerror(ls, "unfinished string", "TK_EOS");
		elseif self:currIsNewline(ls) then
			self:lexerror(ls, "unfinished string", "TK_STRING");
		elseif (c == "\\") then
			c = self:nextc(ls);
			if self:currIsNewline(ls) then
				self:save(ls, "\n");
				self:inclinenumber(ls);
			elseif (c ~= "EOZ") then
				local i = string.find("abfnrtv", c, 1, 1);
				if i then
					self:save(ls, string.sub("\a\b\f\n\r\t\v", i, i));
					self:nextc(ls);
				elseif not string.find(c, "%d") then
					self:save_and_next(ls);
				else
					c, i = 0, 0;
					repeat
						c = (10 * c) + ls.current;
						self:nextc(ls);
						i = i + 1;
					until (i >= 3) or not string.find(ls.current, "%d") 
					if (c > 255) then
						self:lexerror(ls, "escape sequence too large", "TK_STRING");
					end
					self:save(ls, string.char(c));
				end
			end
		else
			self:save_and_next(ls);
		end
	end
	self:save_and_next(ls);
	Token.seminfo = string.sub(ls.buff, 2, -2);
end;
luaX.llex = function(self, ls, Token)
	ls.buff = "";
	while true do
		local c = ls.current;
		if self:currIsNewline(ls) then
			self:inclinenumber(ls);
		elseif (c == "-") then
			c = self:nextc(ls);
			if (c ~= "-") then
				return "-";
			end
			local sep = -1;
			if (self:nextc(ls) == "[") then
				sep = self:skip_sep(ls);
				ls.buff = "";
			end
			if (sep >= 0) then
				self:read_long_string(ls, nil, sep);
				ls.buff = "";
			else
				while not self:currIsNewline(ls) and (ls.current ~= "EOZ") do
					self:nextc(ls);
				end
			end
		elseif (c == "[") then
			local sep = self:skip_sep(ls);
			if (sep >= 0) then
				self:read_long_string(ls, Token, sep);
				return "TK_STRING";
			elseif (sep == -1) then
				return "[";
			else
				self:lexerror(ls, "invalid long string delimiter", "TK_STRING");
			end
		elseif (c == "=") then
			c = self:nextc(ls);
			if (c ~= "=") then
				return "=";
			else
				self:nextc(ls);
				return "TK_EQ";
			end
		elseif (c == "<") then
			c = self:nextc(ls);
			if (c ~= "=") then
				return "<";
			else
				self:nextc(ls);
				return "TK_LE";
			end
		elseif (c == ">") then
			c = self:nextc(ls);
			if (c ~= "=") then
				return ">";
			else
				self:nextc(ls);
				return "TK_GE";
			end
		elseif (c == "~") then
			c = self:nextc(ls);
			if (c ~= "=") then
				return "~";
			else
				self:nextc(ls);
				return "TK_NE";
			end
		elseif ((c == '\"') or (c == "'") or (c == "`")) then
			self:read_string(ls, c, Token);
			return "TK_STRING";
		elseif (c == ".") then
			c = self:save_and_next(ls);
			if self:check_next(ls, ".") then
				if self:check_next(ls, ".") then
					return "TK_DOTS";
				else
					return "TK_CONCAT";
				end
			elseif not string.find(c, "%d") then
				return ".";
			else
				self:read_numeral(ls, Token);
				return "TK_NUMBER";
			end
		elseif (c == "EOZ") then
			return "TK_EOS";
		elseif string.find(c, "%s") then
			self:nextc(ls);
		elseif string.find(c, "%d") then
			self:read_numeral(ls, Token);
			return "TK_NUMBER";
		elseif string.find(c, "[_%a]") then
			repeat
				c = self:save_and_next(ls);
			until (c == "EOZ") or not string.find(c, "[_%w]") 
			local ts = ls.buff;
			local tok = self.enums[ts];
			if tok then
				return tok;
			end
			Token.seminfo = ts;
			return "TK_NAME";
		else
			self:nextc(ls);
			return c;
		end
	end
end;
luaP.OpMode = {iABC=0,iABx=1,iAsBx=2};
luaP.SIZE_C = 9;
luaP.SIZE_B = 9;
luaP.SIZE_Bx = luaP.SIZE_C + luaP.SIZE_B;
luaP.SIZE_A = 8;
luaP.SIZE_OP = 6;
luaP.POS_OP = 0;
luaP.POS_A = luaP.POS_OP + luaP.SIZE_OP;
luaP.POS_C = luaP.POS_A + luaP.SIZE_A;
luaP.POS_B = luaP.POS_C + luaP.SIZE_C;
luaP.POS_Bx = luaP.POS_C;
luaP.MAXARG_Bx = math.ldexp(1, luaP.SIZE_Bx) - 1;
luaP.MAXARG_sBx = math.floor(luaP.MAXARG_Bx / 2);
luaP.MAXARG_A = math.ldexp(1, luaP.SIZE_A) - 1;
luaP.MAXARG_B = math.ldexp(1, luaP.SIZE_B) - 1;
luaP.MAXARG_C = math.ldexp(1, luaP.SIZE_C) - 1;
luaP.GET_OPCODE = function(self, i)
	return self.ROpCode[i.OP];
end;
luaP.SET_OPCODE = function(self, i, o)
	i.OP = self.OpCode[o];
end;
luaP.GETARG_A = function(self, i)
	return i.A;
end;
luaP.SETARG_A = function(self, i, u)
	i.A = u;
end;
luaP.GETARG_B = function(self, i)
	return i.B;
end;
luaP.SETARG_B = function(self, i, b)
	i.B = b;
end;
luaP.GETARG_C = function(self, i)
	return i.C;
end;
luaP.SETARG_C = function(self, i, b)
	i.C = b;
end;
luaP.GETARG_Bx = function(self, i)
	return i.Bx;
end;
luaP.SETARG_Bx = function(self, i, b)
	i.Bx = b;
end;
luaP.GETARG_sBx = function(self, i)
	return i.Bx - self.MAXARG_sBx;
end;
luaP.SETARG_sBx = function(self, i, b)
	i.Bx = b + self.MAXARG_sBx;
end;
luaP.CREATE_ABC = function(self, o, a, b, c)
	return {OP=self.OpCode[o],A=a,B=b,C=c};
end;
luaP.CREATE_ABx = function(self, o, a, bc)
	return {OP=self.OpCode[o],A=a,Bx=bc};
end;
luaP.CREATE_Inst = function(self, c)
	local o = c % 64;
	c = (c - o) / 64;
	local a = c % 256;
	c = (c - a) / 256;
	return self:CREATE_ABx(o, a, c);
end;
luaP.Instruction = function(self, i)
	if i.Bx then
		i.C = i.Bx % 512;
		i.B = (i.Bx - i.C) / 512;
	end
	local I = (i.A * 64) + i.OP;
	local c0 = I % 256;
	I = (i.C * 64) + ((I - c0) / 256);
	local c1 = I % 256;
	I = (i.B * 128) + ((I - c1) / 256);
	local c2 = I % 256;
	local c3 = (I - c2) / 256;
	return string.char(c0, c1, c2, c3);
end;
luaP.DecodeInst = function(self, x)
	local byte = string.byte;
	local i = {};
	local I = byte(x, 1);
	local op = I % 64;
	i.OP = op;
	I = (byte(x, 2) * 4) + ((I - op) / 64);
	local a = I % 256;
	i.A = a;
	I = (byte(x, 3) * 4) + ((I - a) / 256);
	local c = I % 512;
	i.C = c;
	i.B = (byte(x, 4) * 2) + ((I - c) / 512);
	local opmode = self.OpMode[tonumber(string.sub(self.opmodes[op + 1], 7, 7))];
	if (opmode ~= "iABC") then
		i.Bx = (i.B * 512) + i.C;
	end
	return i;
end;
luaP.BITRK = math.ldexp(1, luaP.SIZE_B - 1);
luaP.ISK = function(self, x)
	return x >= self.BITRK;
end;
luaP.INDEXK = function(self, x)
	return x - self.BITRK;
end;
luaP.MAXINDEXRK = luaP.BITRK - 1;
luaP.RKASK = function(self, x)
	return x + self.BITRK;
end;
luaP.NO_REG = luaP.MAXARG_A;
luaP.opnames = {};
luaP.OpCode = {};
luaP.ROpCode = {};
local i = 0;
for v in string.gmatch([[
MOVE LOADK LOADBOOL LOADNIL GETUPVAL
GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
NEWTABLE SELF ADD SUB MUL
DIV MOD POW UNM NOT
LEN CONCAT JMP EQ LT
LE TEST TESTSET CALL TAILCALL
RETURN FORLOOP FORPREP TFORLOOP SETLIST
CLOSE CLOSURE VARARG
]], "%S+") do
	local n = "OP_" .. v;
	luaP.opnames[i] = v;
	luaP.OpCode[n] = i;
	luaP.ROpCode[i] = n;
	i = i + 1;
end
luaP.NUM_OPCODES = i;
luaP.OpArgMask = {OpArgN=0,OpArgU=1,OpArgR=2,OpArgK=3};
luaP.getOpMode = function(self, m)
	return self.opmodes[self.OpCode[m]] % 4;
end;
luaP.getBMode = function(self, m)
	return math.floor(self.opmodes[self.OpCode[m]] / 16) % 4;
end;
luaP.getCMode = function(self, m)
	return math.floor(self.opmodes[self.OpCode[m]] / 4) % 4;
end;
luaP.testAMode = function(self, m)
	return math.floor(self.opmodes[self.OpCode[m]] / 64) % 2;
end;
luaP.testTMode = function(self, m)
	return math.floor(self.opmodes[self.OpCode[m]] / 128);
end;
luaP.LFIELDS_PER_FLUSH = 50;
local function opmode(t, a, b, c, m)
	local luaP = luaP;
	return (t * 128) + (a * 64) + (luaP.OpArgMask[b] * 16) + (luaP.OpArgMask[c] * 4) + luaP.OpMode[m];
end
luaP.opmodes = {opmode(0, 1, "OpArgK", "OpArgN", "iABx"),opmode(0, 1, "OpArgU", "OpArgU", "iABC"),opmode(0, 1, "OpArgR", "OpArgN", "iABC"),opmode(0, 1, "OpArgU", "OpArgN", "iABC"),opmode(0, 1, "OpArgK", "OpArgN", "iABx"),opmode(0, 1, "OpArgR", "OpArgK", "iABC"),opmode(0, 0, "OpArgK", "OpArgN", "iABx"),opmode(0, 0, "OpArgU", "OpArgN", "iABC"),opmode(0, 0, "OpArgK", "OpArgK", "iABC"),opmode(0, 1, "OpArgU", "OpArgU", "iABC"),opmode(0, 1, "OpArgR", "OpArgK", "iABC"),opmode(0, 1, "OpArgK", "OpArgK", "iABC"),opmode(0, 1, "OpArgK", "OpArgK", "iABC"),opmode(0, 1, "OpArgK", "OpArgK", "iABC"),opmode(0, 1, "OpArgK", "OpArgK", "iABC"),opmode(0, 1, "OpArgK", "OpArgK", "iABC"),opmode(0, 1, "OpArgK", "OpArgK", "iABC"),opmode(0, 1, "OpArgR", "OpArgN", "iABC"),opmode(0, 1, "OpArgR", "OpArgN", "iABC"),opmode(0, 1, "OpArgR", "OpArgN", "iABC"),opmode(0, 1, "OpArgR", "OpArgR", "iABC"),opmode(0, 0, "OpArgR", "OpArgN", "iAsBx"),opmode(1, 0, "OpArgK", "OpArgK", "iABC"),opmode(1, 0, "OpArgK", "OpArgK", "iABC"),opmode(1, 0, "OpArgK", "OpArgK", "iABC"),opmode(1, 1, "OpArgR", "OpArgU", "iABC"),opmode(1, 1, "OpArgR", "OpArgU", "iABC"),opmode(0, 1, "OpArgU", "OpArgU", "iABC"),opmode(0, 1, "OpArgU", "OpArgU", "iABC"),opmode(0, 0, "OpArgU", "OpArgN", "iABC"),opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),opmode(1, 0, "OpArgN", "OpArgU", "iABC"),opmode(0, 0, "OpArgU", "OpArgU", "iABC"),opmode(0, 0, "OpArgN", "OpArgN", "iABC"),opmode(0, 1, "OpArgU", "OpArgN", "iABx"),opmode(0, 1, "OpArgU", "OpArgN", "iABC")};
luaP.opmodes[0] = opmode(0, 1, "OpArgR", "OpArgN", "iABC");
luaU.LUA_SIGNATURE = "\27Lua";
luaU.LUA_TNUMBER = 3;
luaU.LUA_TSTRING = 4;
luaU.LUA_TNIL = 0;
luaU.LUA_TBOOLEAN = 1;
luaU.LUA_TNONE = -1;
luaU.LUAC_VERSION = 81;
luaU.LUAC_FORMAT = 0;
luaU.LUAC_HEADERSIZE = 12;
luaU.make_setS = function(self)
	local buff = {};
	buff.data = "";
	local writer = function(s, buff)
		if not s then
			return 0;
		end
		buff.data = buff.data .. s;
		return 0;
	end;
	return writer, buff;
end;
luaU.ttype = function(self, o)
	local tt = type(o.value);
	if (tt == "number") then
		return self.LUA_TNUMBER;
	elseif (tt == "string") then
		return self.LUA_TSTRING;
	elseif (tt == "nil") then
		return self.LUA_TNIL;
	elseif (tt == "boolean") then
		return self.LUA_TBOOLEAN;
	else
		return self.LUA_TNONE;
	end
end;
luaU.from_double = function(self, x)
	local function grab_byte(v)
		local c = v % 256;
		return (v - c) / 256, string.char(c);
	end
	local sign = 0;
	if (x < 0) then
		sign = 1;
		x = -x;
	end
	local mantissa, exponent = math.frexp(x);
	if (x == 0) then
		mantissa, exponent = 0, 0;
	elseif (x == (1 / 0)) then
		mantissa, exponent = 0, 2047;
	else
		mantissa = ((mantissa * 2) - 1) * math.ldexp(0.5, 53);
		exponent = exponent + 1022;
	end
	local v, byte = "", "";
	x = math.floor(mantissa);
	for i = 1, 6 do
		x, byte = grab_byte(x);
		v = v .. byte;
	end
	x, byte = grab_byte((exponent * 16) + x);
	v = v .. byte;
	x, byte = grab_byte((sign * 128) + x);
	v = v .. byte;
	return v;
end;
luaU.from_int = function(self, x)
	local v = "";
	x = math.floor(x);
	if (x < 0) then
		x = 4294967296 + x;
	end
	for i = 1, 4 do
		local c = x % 256;
		v = v .. string.char(c);
		x = math.floor(x / 256);
	end
	return v;
end;
luaU.DumpBlock = function(self, b, D)
	if (D.status == 0) then
		D.status = D.write(b, D.data);
	end
end;
luaU.DumpChar = function(self, y, D)
	self:DumpBlock(string.char(y), D);
end;
luaU.DumpInt = function(self, x, D)
	self:DumpBlock(self:from_int(x), D);
end;
luaU.DumpSizeT = function(self, x, D)
	self:DumpBlock(self:from_int(x), D);
	if (size_size_t == 8) then
		self:DumpBlock(self:from_int(0), D);
	end
end;
luaU.DumpNumber = function(self, x, D)
	self:DumpBlock(self:from_double(x), D);
end;
luaU.DumpString = function(self, s, D)
	if (s == nil) then
		self:DumpSizeT(0, D);
	else
		s = s .. "\0";
		self:DumpSizeT(#s, D);
		self:DumpBlock(s, D);
	end
end;
luaU.DumpCode = function(self, f, D)
	local n = f.sizecode;
	self:DumpInt(n, D);
	for i = 0, n - 1 do
		self:DumpBlock(luaP:Instruction(f.code[i]), D);
	end
end;
luaU.DumpConstants = function(self, f, D)
	local n = f.sizek;
	self:DumpInt(n, D);
	for i = 0, n - 1 do
		local o = f.k[i];
		local tt = self:ttype(o);
		self:DumpChar(tt, D);
		if (tt == self.LUA_TNIL) then
		elseif (tt == self.LUA_TBOOLEAN) then
			self:DumpChar((o.value and 1) or 0, D);
		elseif (tt == self.LUA_TNUMBER) then
			self:DumpNumber(o.value, D);
		elseif (tt == self.LUA_TSTRING) then
			self:DumpString(o.value, D);
		else
		end
	end
	n = f.sizep;
	self:DumpInt(n, D);
	for i = 0, n - 1 do
		self:DumpFunction(f.p[i], f.source, D);
	end
end;
luaU.DumpDebug = function(self, f, D)
	local n;
	n = (D.strip and 0) or f.sizelineinfo;
	self:DumpInt(n, D);
	for i = 0, n - 1 do
		self:DumpInt(f.lineinfo[i], D);
	end
	n = (D.strip and 0) or f.sizelocvars;
	self:DumpInt(n, D);
	for i = 0, n - 1 do
		self:DumpString(f.locvars[i].varname, D);
		self:DumpInt(f.locvars[i].startpc, D);
		self:DumpInt(f.locvars[i].endpc, D);
	end
	n = (D.strip and 0) or f.sizeupvalues;
	self:DumpInt(n, D);
	for i = 0, n - 1 do
		self:DumpString(f.upvalues[i], D);
	end
end;
luaU.DumpFunction = function(self, f, p, D)
	local source = f.source;
	if ((source == p) or D.strip) then
		source = nil;
	end
	self:DumpString(source, D);
	self:DumpInt(f.lineDefined, D);
	self:DumpInt(f.lastlinedefined, D);
	self:DumpChar(f.nups, D);
	self:DumpChar(f.numparams, D);
	self:DumpChar(f.is_vararg, D);
	self:DumpChar(f.maxstacksize, D);
	self:DumpCode(f, D);
	self:DumpConstants(f, D);
	self:DumpDebug(f, D);
end;
luaU.DumpHeader = function(self, D)
	local h = self:header();
	assert(#h == self.LUAC_HEADERSIZE);
	self:DumpBlock(h, D);
end;
luaU.header = function(self)
	local x = 1;
	return self.LUA_SIGNATURE .. string.char(self.LUAC_VERSION, self.LUAC_FORMAT, x, 4, size_size_t, 4, 8, 0);
end;
luaU.dump = function(self, L, f, w, data, strip)
	local D = {};
	D.L = L;
	D.write = w;
	D.data = data;
	D.strip = strip;
	D.status = 0;
	self:DumpHeader(D);
	self:DumpFunction(f, nil, D);
	D.write(nil, D.data);
	return D.status;
end;
luaK.MAXSTACK = 250;
luaK.ttisnumber = function(self, o)
	if o then
		return type(o.value) == "number";
	else
		return false;
	end
end;
luaK.nvalue = function(self, o)
	return o.value;
end;
luaK.setnilvalue = function(self, o)
	o.value = nil;
end;
luaK.setsvalue = function(self, o, x)
	o.value = x;
end;
luaK.setnvalue = luaK.setsvalue;
luaK.sethvalue = luaK.setsvalue;
luaK.setbvalue = luaK.setsvalue;
luaK.numadd = function(self, a, b)
	return a + b;
end;
luaK.numsub = function(self, a, b)
	return a - b;
end;
luaK.nummul = function(self, a, b)
	return a * b;
end;
luaK.numdiv = function(self, a, b)
	return a / b;
end;
luaK.nummod = function(self, a, b)
	return a % b;
end;
luaK.numpow = function(self, a, b)
	return a ^ b;
end;
luaK.numunm = function(self, a)
	return -a;
end;
luaK.numisnan = function(self, a)
	return a ~= a;
end;
luaK.NO_JUMP = -1;
luaK.BinOpr = {OPR_ADD=0,OPR_SUB=1,OPR_MUL=2,OPR_DIV=3,OPR_MOD=4,OPR_POW=5,OPR_CONCAT=6,OPR_NE=7,OPR_EQ=8,OPR_LT=9,OPR_LE=10,OPR_GT=11,OPR_GE=12,OPR_AND=13,OPR_OR=14,OPR_NOBINOPR=15};
luaK.UnOpr = {OPR_MINUS=0,OPR_NOT=1,OPR_LEN=2,OPR_NOUNOPR=3};
luaK.getcode = function(self, fs, e)
	return fs.f.code[e.info];
end;
luaK.codeAsBx = function(self, fs, o, A, sBx)
	return self:codeABx(fs, o, A, sBx + luaP.MAXARG_sBx);
end;
luaK.setmultret = function(self, fs, e)
	self:setreturns(fs, e, luaY.LUA_MULTRET);
end;
luaK.hasjumps = function(self, e)
	return e.t ~= e.f;
end;
luaK.isnumeral = function(self, e)
	return (e.k == "VKNUM") and (e.t == self.NO_JUMP) and (e.f == self.NO_JUMP);
end;
luaK._nil = function(self, fs, from, n)
	if (fs.pc > fs.lasttarget) then
		if (fs.pc == 0) then
			if (from >= fs.nactvar) then
				return;
			end
		else
			local previous = fs.f.code[fs.pc - 1];
			if (luaP:GET_OPCODE(previous) == "OP_LOADNIL") then
				local pfrom = luaP:GETARG_A(previous);
				local pto = luaP:GETARG_B(previous);
				if ((pfrom <= from) and (from <= (pto + 1))) then
					if (((from + n) - 1) > pto) then
						luaP:SETARG_B(previous, (from + n) - 1);
					end
					return;
				end
			end
		end
	end
	self:codeABC(fs, "OP_LOADNIL", from, (from + n) - 1, 0);
end;
luaK.jump = function(self, fs)
	local jpc = fs.jpc;
	fs.jpc = self.NO_JUMP;
	local j = self:codeAsBx(fs, "OP_JMP", 0, self.NO_JUMP);
	j = self:concat(fs, j, jpc);
	return j;
end;
luaK.ret = function(self, fs, first, nret)
	self:codeABC(fs, "OP_RETURN", first, nret + 1, 0);
end;
luaK.condjump = function(self, fs, op, A, B, C)
	self:codeABC(fs, op, A, B, C);
	return self:jump(fs);
end;
luaK.fixjump = function(self, fs, pc, dest)
	local jmp = fs.f.code[pc];
	local offset = dest - (pc + 1);
	lua_assert(dest ~= self.NO_JUMP);
	if (math.abs(offset) > luaP.MAXARG_sBx) then
		luaX:syntaxerror(fs.ls, "control structure too long");
	end
	luaP:SETARG_sBx(jmp, offset);
end;
luaK.getlabel = function(self, fs)
	fs.lasttarget = fs.pc;
	return fs.pc;
end;
luaK.getjump = function(self, fs, pc)
	local offset = luaP:GETARG_sBx(fs.f.code[pc]);
	if (offset == self.NO_JUMP) then
		return self.NO_JUMP;
	else
		return pc + 1 + offset;
	end
end;
luaK.getjumpcontrol = function(self, fs, pc)
	local pi = fs.f.code[pc];
	local ppi = fs.f.code[pc - 1];
	if ((pc >= 1) and (luaP:testTMode(luaP:GET_OPCODE(ppi)) ~= 0)) then
		return ppi;
	else
		return pi;
	end
end;
luaK.need_value = function(self, fs, list)
	while list ~= self.NO_JUMP do
		local i = self:getjumpcontrol(fs, list);
		if (luaP:GET_OPCODE(i) ~= "OP_TESTSET") then
			return true;
		end
		list = self:getjump(fs, list);
	end
	return false;
end;
luaK.patchtestreg = function(self, fs, node, reg)
	local i = self:getjumpcontrol(fs, node);
	if (luaP:GET_OPCODE(i) ~= "OP_TESTSET") then
		return false;
	end
	if ((reg ~= luaP.NO_REG) and (reg ~= luaP:GETARG_B(i))) then
		luaP:SETARG_A(i, reg);
	else
		luaP:SET_OPCODE(i, "OP_TEST");
		local b = luaP:GETARG_B(i);
		luaP:SETARG_A(i, b);
		luaP:SETARG_B(i, 0);
	end
	return true;
end;
luaK.removevalues = function(self, fs, list)
	while list ~= self.NO_JUMP do
		self:patchtestreg(fs, list, luaP.NO_REG);
		list = self:getjump(fs, list);
	end
end;
luaK.patchlistaux = function(self, fs, list, vtarget, reg, dtarget)
	while list ~= self.NO_JUMP do
		local _next = self:getjump(fs, list);
		if self:patchtestreg(fs, list, reg) then
			self:fixjump(fs, list, vtarget);
		else
			self:fixjump(fs, list, dtarget);
		end
		list = _next;
	end
end;
luaK.dischargejpc = function(self, fs)
	self:patchlistaux(fs, fs.jpc, fs.pc, luaP.NO_REG, fs.pc);
	fs.jpc = self.NO_JUMP;
end;
luaK.patchlist = function(self, fs, list, target)
	if (target == fs.pc) then
		self:patchtohere(fs, list);
	else
		lua_assert(target < fs.pc);
		self:patchlistaux(fs, list, target, luaP.NO_REG, target);
	end
end;
luaK.patchtohere = function(self, fs, list)
	self:getlabel(fs);
	fs.jpc = self:concat(fs, fs.jpc, list);
end;
luaK.concat = function(self, fs, l1, l2)
	if (l2 == self.NO_JUMP) then
		return l1;
	elseif (l1 == self.NO_JUMP) then
		return l2;
	else
		local list = l1;
		local _next = self:getjump(fs, list);
		while _next ~= self.NO_JUMP do
			list = _next;
			_next = self:getjump(fs, list);
		end
		self:fixjump(fs, list, l2);
	end
	return l1;
end;
luaK.checkstack = function(self, fs, n)
	local newstack = fs.freereg + n;
	if (newstack > fs.f.maxstacksize) then
		if (newstack >= self.MAXSTACK) then
			luaX:syntaxerror(fs.ls, "function or expression too complex");
		end
		fs.f.maxstacksize = newstack;
	end
end;
luaK.reserveregs = function(self, fs, n)
	self:checkstack(fs, n);
	fs.freereg = fs.freereg + n;
end;
luaK.freereg = function(self, fs, reg)
	if (not luaP:ISK(reg) and (reg >= fs.nactvar)) then
		fs.freereg = fs.freereg - 1;
		lua_assert(reg == fs.freereg);
	end
end;
luaK.freeexp = function(self, fs, e)
	if (e.k == "VNONRELOC") then
		self:freereg(fs, e.info);
	end
end;
luaK.addk = function(self, fs, k, v)
	local L = fs.L;
	local idx = fs.h[k.value];
	local f = fs.f;
	if self:ttisnumber(idx) then
		return self:nvalue(idx);
	else
		idx = {};
		self:setnvalue(idx, fs.nk);
		fs.h[k.value] = idx;
		luaY:growvector(L, f.k, fs.nk, f.sizek, nil, luaP.MAXARG_Bx, "constant table overflow");
		f.k[fs.nk] = v;
		local nk = fs.nk;
		fs.nk = fs.nk + 1;
		return nk;
	end
end;
luaK.stringK = function(self, fs, s)
	local o = {};
	self:setsvalue(o, s);
	return self:addk(fs, o, o);
end;
luaK.numberK = function(self, fs, r)
	local o = {};
	self:setnvalue(o, r);
	return self:addk(fs, o, o);
end;
luaK.boolK = function(self, fs, b)
	local o = {};
	self:setbvalue(o, b);
	return self:addk(fs, o, o);
end;
luaK.nilK = function(self, fs)
	local k, v = {}, {};
	self:setnilvalue(v);
	self:sethvalue(k, fs.h);
	return self:addk(fs, k, v);
end;
luaK.setreturns = function(self, fs, e, nresults)
	if (e.k == "VCALL") then
		luaP:SETARG_C(self:getcode(fs, e), nresults + 1);
	elseif (e.k == "VVARARG") then
		luaP:SETARG_B(self:getcode(fs, e), nresults + 1);
		luaP:SETARG_A(self:getcode(fs, e), fs.freereg);
		luaK:reserveregs(fs, 1);
	end
end;
luaK.setoneret = function(self, fs, e)
	if (e.k == "VCALL") then
		e.k = "VNONRELOC";
		e.info = luaP:GETARG_A(self:getcode(fs, e));
	elseif (e.k == "VVARARG") then
		luaP:SETARG_B(self:getcode(fs, e), 2);
		e.k = "VRELOCABLE";
	end
end;
luaK.dischargevars = function(self, fs, e)
	local k = e.k;
	if (k == "VLOCAL") then
		e.k = "VNONRELOC";
	elseif (k == "VUPVAL") then
		e.info = self:codeABC(fs, "OP_GETUPVAL", 0, e.info, 0);
		e.k = "VRELOCABLE";
	elseif (k == "VGLOBAL") then
		e.info = self:codeABx(fs, "OP_GETGLOBAL", 0, e.info);
		e.k = "VRELOCABLE";
	elseif (k == "VINDEXED") then
		self:freereg(fs, e.aux);
		self:freereg(fs, e.info);
		e.info = self:codeABC(fs, "OP_GETTABLE", 0, e.info, e.aux);
		e.k = "VRELOCABLE";
	elseif ((k == "VVARARG") or (k == "VCALL")) then
		self:setoneret(fs, e);
	else
	end
end;
luaK.code_label = function(self, fs, A, b, jump)
	self:getlabel(fs);
	return self:codeABC(fs, "OP_LOADBOOL", A, b, jump);
end;
luaK.discharge2reg = function(self, fs, e, reg)
	self:dischargevars(fs, e);
	local k = e.k;
	if (k == "VNIL") then
		self:_nil(fs, reg, 1);
	elseif ((k == "VFALSE") or (k == "VTRUE")) then
		self:codeABC(fs, "OP_LOADBOOL", reg, ((e.k == "VTRUE") and 1) or 0, 0);
	elseif (k == "VK") then
		self:codeABx(fs, "OP_LOADK", reg, e.info);
	elseif (k == "VKNUM") then
		self:codeABx(fs, "OP_LOADK", reg, self:numberK(fs, e.nval));
	elseif (k == "VRELOCABLE") then
		local pc = self:getcode(fs, e);
		luaP:SETARG_A(pc, reg);
	elseif (k == "VNONRELOC") then
		if (reg ~= e.info) then
			self:codeABC(fs, "OP_MOVE", reg, e.info, 0);
		end
	else
		lua_assert((e.k == "VVOID") or (e.k == "VJMP"));
		return;
	end
	e.info = reg;
	e.k = "VNONRELOC";
end;
luaK.discharge2anyreg = function(self, fs, e)
	if (e.k ~= "VNONRELOC") then
		self:reserveregs(fs, 1);
		self:discharge2reg(fs, e, fs.freereg - 1);
	end
end;
luaK.exp2reg = function(self, fs, e, reg)
	self:discharge2reg(fs, e, reg);
	if (e.k == "VJMP") then
		e.t = self:concat(fs, e.t, e.info);
	end
	if self:hasjumps(e) then
		local final;
		local p_f = self.NO_JUMP;
		local p_t = self.NO_JUMP;
		if (self:need_value(fs, e.t) or self:need_value(fs, e.f)) then
			local fj = ((e.k == "VJMP") and self.NO_JUMP) or self:jump(fs);
			p_f = self:code_label(fs, reg, 0, 1);
			p_t = self:code_label(fs, reg, 1, 0);
			self:patchtohere(fs, fj);
		end
		final = self:getlabel(fs);
		self:patchlistaux(fs, e.f, final, reg, p_f);
		self:patchlistaux(fs, e.t, final, reg, p_t);
	end
	e.f, e.t = self.NO_JUMP, self.NO_JUMP;
	e.info = reg;
	e.k = "VNONRELOC";
end;
luaK.exp2nextreg = function(self, fs, e)
	self:dischargevars(fs, e);
	self:freeexp(fs, e);
	self:reserveregs(fs, 1);
	self:exp2reg(fs, e, fs.freereg - 1);
end;
luaK.exp2anyreg = function(self, fs, e)
	self:dischargevars(fs, e);
	if (e.k == "VNONRELOC") then
		if not self:hasjumps(e) then
			return e.info;
		end
		if (e.info >= fs.nactvar) then
			self:exp2reg(fs, e, e.info);
			return e.info;
		end
	end
	self:exp2nextreg(fs, e);
	return e.info;
end;
luaK.exp2val = function(self, fs, e)
	if self:hasjumps(e) then
		self:exp2anyreg(fs, e);
	else
		self:dischargevars(fs, e);
	end
end;
luaK.exp2RK = function(self, fs, e)
	self:exp2val(fs, e);
	local k = e.k;
	if ((k == "VKNUM") or (k == "VTRUE") or (k == "VFALSE") or (k == "VNIL")) then
		if (fs.nk <= luaP.MAXINDEXRK) then
			if (e.k == "VNIL") then
				e.info = self:nilK(fs);
			else
				e.info = ((e.k == "VKNUM") and self:numberK(fs, e.nval)) or self:boolK(fs, e.k == "VTRUE");
			end
			e.k = "VK";
			return luaP:RKASK(e.info);
		end
	elseif (k == "VK") then
		if (e.info <= luaP.MAXINDEXRK) then
			return luaP:RKASK(e.info);
		end
	else
	end
	return self:exp2anyreg(fs, e);
end;
luaK.storevar = function(self, fs, var, ex)
	local k = var.k;
	if (k == "VLOCAL") then
		self:freeexp(fs, ex);
		self:exp2reg(fs, ex, var.info);
		return;
	elseif (k == "VUPVAL") then
		local e = self:exp2anyreg(fs, ex);
		self:codeABC(fs, "OP_SETUPVAL", e, var.info, 0);
	elseif (k == "VGLOBAL") then
		local e = self:exp2anyreg(fs, ex);
		self:codeABx(fs, "OP_SETGLOBAL", e, var.info);
	elseif (k == "VINDEXED") then
		local e = self:exp2RK(fs, ex);
		self:codeABC(fs, "OP_SETTABLE", var.info, var.aux, e);
	else
		lua_assert(0);
	end
	self:freeexp(fs, ex);
end;
luaK._self = function(self, fs, e, key)
	self:exp2anyreg(fs, e);
	self:freeexp(fs, e);
	local func = fs.freereg;
	self:reserveregs(fs, 2);
	self:codeABC(fs, "OP_SELF", func, e.info, self:exp2RK(fs, key));
	self:freeexp(fs, key);
	e.info = func;
	e.k = "VNONRELOC";
end;
luaK.invertjump = function(self, fs, e)
	local pc = self:getjumpcontrol(fs, e.info);
	lua_assert((luaP:testTMode(luaP:GET_OPCODE(pc)) ~= 0) and (luaP:GET_OPCODE(pc) ~= "OP_TESTSET") and (luaP:GET_OPCODE(pc) ~= "OP_TEST"));
	luaP:SETARG_A(pc, ((luaP:GETARG_A(pc) == 0) and 1) or 0);
end;
luaK.jumponcond = function(self, fs, e, cond)
	if (e.k == "VRELOCABLE") then
		local ie = self:getcode(fs, e);
		if (luaP:GET_OPCODE(ie) == "OP_NOT") then
			fs.pc = fs.pc - 1;
			return self:condjump(fs, "OP_TEST", luaP:GETARG_B(ie), 0, (cond and 0) or 1);
		end
	end
	self:discharge2anyreg(fs, e);
	self:freeexp(fs, e);
	return self:condjump(fs, "OP_TESTSET", luaP.NO_REG, e.info, (cond and 1) or 0);
end;
luaK.goiftrue = function(self, fs, e)
	local pc;
	self:dischargevars(fs, e);
	local k = e.k;
	if ((k == "VK") or (k == "VKNUM") or (k == "VTRUE")) then
		pc = self.NO_JUMP;
	elseif (k == "VFALSE") then
		pc = self:jump(fs);
	elseif (k == "VJMP") then
		self:invertjump(fs, e);
		pc = e.info;
	else
		pc = self:jumponcond(fs, e, false);
	end
	e.f = self:concat(fs, e.f, pc);
	self:patchtohere(fs, e.t);
	e.t = self.NO_JUMP;
end;
luaK.goiffalse = function(self, fs, e)
	local pc;
	self:dischargevars(fs, e);
	local k = e.k;
	if ((k == "VNIL") or (k == "VFALSE")) then
		pc = self.NO_JUMP;
	elseif (k == "VTRUE") then
		pc = self:jump(fs);
	elseif (k == "VJMP") then
		pc = e.info;
	else
		pc = self:jumponcond(fs, e, true);
	end
	e.t = self:concat(fs, e.t, pc);
	self:patchtohere(fs, e.f);
	e.f = self.NO_JUMP;
end;
luaK.codenot = function(self, fs, e)
	self:dischargevars(fs, e);
	local k = e.k;
	if ((k == "VNIL") or (k == "VFALSE")) then
		e.k = "VTRUE";
	elseif ((k == "VK") or (k == "VKNUM") or (k == "VTRUE")) then
		e.k = "VFALSE";
	elseif (k == "VJMP") then
		self:invertjump(fs, e);
	elseif ((k == "VRELOCABLE") or (k == "VNONRELOC")) then
		self:discharge2anyreg(fs, e);
		self:freeexp(fs, e);
		e.info = self:codeABC(fs, "OP_NOT", 0, e.info, 0);
		e.k = "VRELOCABLE";
	else
		lua_assert(0);
	end
	e.f, e.t = e.t, e.f;
	self:removevalues(fs, e.f);
	self:removevalues(fs, e.t);
end;
luaK.indexed = function(self, fs, t, k)
	t.aux = self:exp2RK(fs, k);
	t.k = "VINDEXED";
end;
luaK.constfolding = function(self, op, e1, e2)
	local r;
	if (not self:isnumeral(e1) or not self:isnumeral(e2)) then
		return false;
	end
	local v1 = e1.nval;
	local v2 = e2.nval;
	if (op == "OP_ADD") then
		r = self:numadd(v1, v2);
	elseif (op == "OP_SUB") then
		r = self:numsub(v1, v2);
	elseif (op == "OP_MUL") then
		r = self:nummul(v1, v2);
	elseif (op == "OP_DIV") then
		if (v2 == 0) then
			return false;
		end
		r = self:numdiv(v1, v2);
	elseif (op == "OP_MOD") then
		if (v2 == 0) then
			return false;
		end
		r = self:nummod(v1, v2);
	elseif (op == "OP_POW") then
		r = self:numpow(v1, v2);
	elseif (op == "OP_UNM") then
		r = self:numunm(v1);
	elseif (op == "OP_LEN") then
		return false;
	else
		lua_assert(0);
		r = 0;
	end
	if self:numisnan(r) then
		return false;
	end
	e1.nval = r;
	return true;
end;
luaK.codearith = function(self, fs, op, e1, e2)
	if self:constfolding(op, e1, e2) then
		return;
	else
		local o2 = ((op ~= "OP_UNM") and (op ~= "OP_LEN") and self:exp2RK(fs, e2)) or 0;
		local o1 = self:exp2RK(fs, e1);
		if (o1 > o2) then
			self:freeexp(fs, e1);
			self:freeexp(fs, e2);
		else
			self:freeexp(fs, e2);
			self:freeexp(fs, e1);
		end
		e1.info = self:codeABC(fs, op, 0, o1, o2);
		e1.k = "VRELOCABLE";
	end
end;
luaK.codecomp = function(self, fs, op, cond, e1, e2)
	local o1 = self:exp2RK(fs, e1);
	local o2 = self:exp2RK(fs, e2);
	self:freeexp(fs, e2);
	self:freeexp(fs, e1);
	if ((cond == 0) and (op ~= "OP_EQ")) then
		o1, o2 = o2, o1;
		cond = 1;
	end
	e1.info = self:condjump(fs, op, cond, o1, o2);
	e1.k = "VJMP";
end;
luaK.prefix = function(self, fs, op, e)
	local e2 = {};
	e2.t, e2.f = self.NO_JUMP, self.NO_JUMP;
	e2.k = "VKNUM";
	e2.nval = 0;
	if (op == "OPR_MINUS") then
		if not self:isnumeral(e) then
			self:exp2anyreg(fs, e);
		end
		self:codearith(fs, "OP_UNM", e, e2);
	elseif (op == "OPR_NOT") then
		self:codenot(fs, e);
	elseif (op == "OPR_LEN") then
		self:exp2anyreg(fs, e);
		self:codearith(fs, "OP_LEN", e, e2);
	else
		lua_assert(0);
	end
end;
luaK.infix = function(self, fs, op, v)
	if (op == "OPR_AND") then
		self:goiftrue(fs, v);
	elseif (op == "OPR_OR") then
		self:goiffalse(fs, v);
	elseif (op == "OPR_CONCAT") then
		self:exp2nextreg(fs, v);
	elseif ((op == "OPR_ADD") or (op == "OPR_SUB") or (op == "OPR_MUL") or (op == "OPR_DIV") or (op == "OPR_MOD") or (op == "OPR_POW")) then
		if not self:isnumeral(v) then
			self:exp2RK(fs, v);
		end
	else
		self:exp2RK(fs, v);
	end
end;
luaK.arith_op = {OPR_ADD="OP_ADD",OPR_SUB="OP_SUB",OPR_MUL="OP_MUL",OPR_DIV="OP_DIV",OPR_MOD="OP_MOD",OPR_POW="OP_POW"};
luaK.comp_op = {OPR_EQ="OP_EQ",OPR_NE="OP_EQ",OPR_LT="OP_LT",OPR_LE="OP_LE",OPR_GT="OP_LT",OPR_GE="OP_LE"};
luaK.comp_cond = {OPR_EQ=1,OPR_NE=0,OPR_LT=1,OPR_LE=1,OPR_GT=0,OPR_GE=0};
luaK.posfix = function(self, fs, op, e1, e2)
	local function copyexp(e1, e2)
		e1.k = e2.k;
		e1.info = e2.info;
		e1.aux = e2.aux;
		e1.nval = e2.nval;
		e1.t = e2.t;
		e1.f = e2.f;
	end
	if (op == "OPR_AND") then
		lua_assert(e1.t == self.NO_JUMP);
		self:dischargevars(fs, e2);
		e2.f = self:concat(fs, e2.f, e1.f);
		copyexp(e1, e2);
	elseif (op == "OPR_OR") then
		lua_assert(e1.f == self.NO_JUMP);
		self:dischargevars(fs, e2);
		e2.t = self:concat(fs, e2.t, e1.t);
		copyexp(e1, e2);
	elseif (op == "OPR_CONCAT") then
		self:exp2val(fs, e2);
		if ((e2.k == "VRELOCABLE") and (luaP:GET_OPCODE(self:getcode(fs, e2)) == "OP_CONCAT")) then
			lua_assert(e1.info == (luaP:GETARG_B(self:getcode(fs, e2)) - 1));
			self:freeexp(fs, e1);
			luaP:SETARG_B(self:getcode(fs, e2), e1.info);
			e1.k = "VRELOCABLE";
			e1.info = e2.info;
		else
			self:exp2nextreg(fs, e2);
			self:codearith(fs, "OP_CONCAT", e1, e2);
		end
	else
		local arith = self.arith_op[op];
		if arith then
			self:codearith(fs, arith, e1, e2);
		else
			local comp = self.comp_op[op];
			if comp then
				self:codecomp(fs, comp, self.comp_cond[op], e1, e2);
			else
				lua_assert(0);
			end
		end
	end
end;
luaK.fixline = function(self, fs, line)
	fs.f.lineinfo[fs.pc - 1] = line;
end;
luaK.code = function(self, fs, i, line)
	local f = fs.f;
	self:dischargejpc(fs);
	luaY:growvector(fs.L, f.code, fs.pc, f.sizecode, nil, luaY.MAX_INT, "code size overflow");
	f.code[fs.pc] = i;
	luaY:growvector(fs.L, f.lineinfo, fs.pc, f.sizelineinfo, nil, luaY.MAX_INT, "code size overflow");
	f.lineinfo[fs.pc] = line;
	local pc = fs.pc;
	fs.pc = fs.pc + 1;
	return pc;
end;
luaK.codeABC = function(self, fs, o, a, b, c)
	lua_assert(luaP:getOpMode(o) == luaP.OpMode.iABC);
	lua_assert((luaP:getBMode(o) ~= luaP.OpArgMask.OpArgN) or (b == 0));
	lua_assert((luaP:getCMode(o) ~= luaP.OpArgMask.OpArgN) or (c == 0));
	return self:code(fs, luaP:CREATE_ABC(o, a, b, c), fs.ls.lastline);
end;
luaK.codeABx = function(self, fs, o, a, bc)
	lua_assert((luaP:getOpMode(o) == luaP.OpMode.iABx) or (luaP:getOpMode(o) == luaP.OpMode.iAsBx));
	lua_assert(luaP:getCMode(o) == luaP.OpArgMask.OpArgN);
	return self:code(fs, luaP:CREATE_ABx(o, a, bc), fs.ls.lastline);
end;
luaK.setlist = function(self, fs, base, nelems, tostore)
	local c = math.floor((nelems - 1) / luaP.LFIELDS_PER_FLUSH) + 1;
	local b = ((tostore == luaY.LUA_MULTRET) and 0) or tostore;
	lua_assert(tostore ~= 0);
	if (c <= luaP.MAXARG_C) then
		self:codeABC(fs, "OP_SETLIST", base, b, c);
	else
		self:codeABC(fs, "OP_SETLIST", base, b, 0);
		self:code(fs, luaP:CREATE_Inst(c), fs.ls.lastline);
	end
	fs.freereg = base + 1;
end;
luaY.LUA_QS = luaX.LUA_QS or "'%s'";
luaY.SHRT_MAX = 32767;
luaY.LUAI_MAXVARS = 200;
luaY.LUAI_MAXUPVALUES = 60;
luaY.MAX_INT = luaX.MAX_INT or 2147483645;
luaY.LUAI_MAXCCALLS = 200;
luaY.VARARG_HASARG = 1;
luaY.HASARG_MASK = 2;
luaY.VARARG_ISVARARG = 2;
luaY.VARARG_NEEDSARG = 4;
luaY.LUA_MULTRET = -1;
luaY.LUA_QL = function(self, x)
	return "'" .. x .. "'";
end;
luaY.growvector = function(self, L, v, nelems, size, t, limit, e)
	if (nelems >= limit) then
		error(e);
	end
end;
luaY.newproto = function(self, L)
	local f = {};
	f.k = {};
	f.sizek = 0;
	f.p = {};
	f.sizep = 0;
	f.code = {};
	f.sizecode = 0;
	f.sizelineinfo = 0;
	f.sizeupvalues = 0;
	f.nups = 0;
	f.upvalues = {};
	f.numparams = 0;
	f.is_vararg = 0;
	f.maxstacksize = 0;
	f.lineinfo = {};
	f.sizelocvars = 0;
	f.locvars = {};
	f.lineDefined = 0;
	f.lastlinedefined = 0;
	f.source = nil;
	return f;
end;
luaY.int2fb = function(self, x)
	local e = 0;
	while x >= 16 do
		x = math.floor((x + 1) / 2);
		e = e + 1;
	end
	if (x < 8) then
		return x;
	else
		return ((e + 1) * 8) + (x - 8);
	end
end;
luaY.hasmultret = function(self, k)
	return (k == "VCALL") or (k == "VVARARG");
end;
luaY.getlocvar = function(self, fs, i)
	return fs.f.locvars[fs.actvar[i]];
end;
luaY.checklimit = function(self, fs, v, l, m)
	if (v > l) then
		self:errorlimit(fs, l, m);
	end
end;
luaY.anchor_token = function(self, ls)
	if ((ls.t.token == "TK_NAME") or (ls.t.token == "TK_STRING")) then
	end
end;
luaY.error_expected = function(self, ls, token)
	luaX:syntaxerror(ls, string.format(self.LUA_QS .. " expected", luaX:token2str(ls, token)));
end;
luaY.errorlimit = function(self, fs, limit, what)
	local msg = ((fs.f.linedefined == 0) and string.format("main function has more than %d %s", limit, what)) or string.format("function at line %d has more than %d %s", fs.f.linedefined, limit, what);
	luaX:lexerror(fs.ls, msg, 0);
end;
luaY.testnext = function(self, ls, c)
	if (ls.t.token == c) then
		luaX:next(ls);
		return true;
	else
		return false;
	end
end;
luaY.check = function(self, ls, c)
	if (ls.t.token ~= c) then
		self:error_expected(ls, c);
	end
end;
luaY.checknext = function(self, ls, c)
	self:check(ls, c);
	luaX:next(ls);
end;
luaY.check_condition = function(self, ls, c, msg)
	if not c then
		luaX:syntaxerror(ls, msg);
	end
end;
luaY.check_match = function(self, ls, what, who, where)
	if not self:testnext(ls, what) then
		if (where == ls.linenumber) then
			self:error_expected(ls, what);
		else
			luaX:syntaxerror(ls, string.format(self.LUA_QS .. " expected (to close " .. self.LUA_QS .. " at line %d)", luaX:token2str(ls, what), luaX:token2str(ls, who), where));
		end
	end
end;
luaY.str_checkname = function(self, ls)
	self:check(ls, "TK_NAME");
	local ts = ls.t.seminfo;
	luaX:next(ls);
	return ts;
end;
luaY.init_exp = function(self, e, k, i)
	e.f, e.t = luaK.NO_JUMP, luaK.NO_JUMP;
	e.k = k;
	e.info = i;
end;
luaY.codestring = function(self, ls, e, s)
	self:init_exp(e, "VK", luaK:stringK(ls.fs, s));
end;
luaY.checkname = function(self, ls, e)
	self:codestring(ls, e, self:str_checkname(ls));
end;
luaY.registerlocalvar = function(self, ls, varname)
	local fs = ls.fs;
	local f = fs.f;
	self:growvector(ls.L, f.locvars, fs.nlocvars, f.sizelocvars, nil, self.SHRT_MAX, "too many local variables");
	f.locvars[fs.nlocvars] = {};
	f.locvars[fs.nlocvars].varname = varname;
	local nlocvars = fs.nlocvars;
	fs.nlocvars = fs.nlocvars + 1;
	return nlocvars;
end;
luaY.new_localvarliteral = function(self, ls, v, n)
	self:new_localvar(ls, v, n);
end;
luaY.new_localvar = function(self, ls, name, n)
	local fs = ls.fs;
	self:checklimit(fs, fs.nactvar + n + 1, self.LUAI_MAXVARS, "local variables");
	fs.actvar[fs.nactvar + n] = self:registerlocalvar(ls, name);
end;
luaY.adjustlocalvars = function(self, ls, nvars)
	local fs = ls.fs;
	fs.nactvar = fs.nactvar + nvars;
	for i = nvars, 1, -1 do
		self:getlocvar(fs, fs.nactvar - i).startpc = fs.pc;
	end
end;
luaY.removevars = function(self, ls, tolevel)
	local fs = ls.fs;
	while fs.nactvar > tolevel do
		fs.nactvar = fs.nactvar - 1;
		self:getlocvar(fs, fs.nactvar).endpc = fs.pc;
	end
end;
luaX:init();
local LuaState = {};
local compile = function(source, name)
	name = name or "compiled-lua";
	local zio = luaZ:init(luaZ:make_getF(source), nil);
	if not zio then
		return;
	end
	local func = luaY:parser(LuaState, zio, nil, "@" .. name);
	local writer, buff = luaU:make_setS();
	luaU:dump(LuaState, func, writer, buff);
	return buff.data;
end;
local createExecutable = function(bCode, env)
	return lua_wrap_state(lua_bc_to_state(bCode), env or getfenv(0));
end;
local newLoadstring = function(source, env)
	if typeof(source) ~= "string" then error("argument 1: string expected, got "..typeof(source)) end
	
	source = string.gsub(source,"loadstring","require(game."..script:GetFullName()..")")

	local executable;
	local env = env or getfenv(2);
	local name = env.script and env.script:GetFullName();
	local ran, failureReason = pcall(function()
		local compiledBytecode = compile(source, name);
		executable = createExecutable(compiledBytecode, env);
	end);
	if ran then
		return setfenv(executable, env);
	end
	return nil, failureReason;
end;
luaY.indexupvalue = function(self, fs, name, v)
	local f = fs.f;
	for i = 0, f.nups - 1 do
		if ((fs.upvalues[i].k == v.k) and (fs.upvalues[i].info == v.info)) then
			lua_assert(f.upvalues[i] == name);
			return i;
		end
	end
	self:checklimit(fs, f.nups + 1, self.LUAI_MAXUPVALUES, "upvalues");
	self:growvector(fs.L, f.upvalues, f.nups, f.sizeupvalues, nil, self.MAX_INT, "");
	f.upvalues[f.nups] = name;
	lua_assert((v.k == "VLOCAL") or (v.k == "VUPVAL"));
	fs.upvalues[f.nups] = {k=v.k,info=v.info};
	local nups = f.nups;
	f.nups = f.nups + 1;
	return nups;
end;
luaY.searchvar = function(self, fs, n)
	for i = fs.nactvar - 1, 0, -1 do
		if (n == self:getlocvar(fs, i).varname) then
			return i;
		end
	end
	return -1;
end;
luaY.markupval = function(self, fs, level)
	local bl = fs.bl;
	while bl and (bl.nactvar > level) do
		bl = bl.previous;
	end
	if bl then
		bl.upval = true;
	end
end;
luaY.singlevaraux = function(self, fs, n, var, base)
	if (fs == nil) then
		self:init_exp(var, "VGLOBAL", luaP.NO_REG);
		return "VGLOBAL";
	else
		local v = self:searchvar(fs, n);
		if (v >= 0) then
			self:init_exp(var, "VLOCAL", v);
			if (base == 0) then
				self:markupval(fs, v);
			end
			return "VLOCAL";
		else
			if (self:singlevaraux(fs.prev, n, var, 0) == "VGLOBAL") then
				return "VGLOBAL";
			end
			var.info = self:indexupvalue(fs, n, var);
			var.k = "VUPVAL";
			return "VUPVAL";
		end
	end
end;
luaY.singlevar = function(self, ls, var)
	local varname = self:str_checkname(ls);
	local fs = ls.fs;
	if (self:singlevaraux(fs, varname, var, 1) == "VGLOBAL") then
		var.info = luaK:stringK(fs, varname);
	end
end;
luaY.adjust_assign = function(self, ls, nvars, nexps, e)
	local fs = ls.fs;
	local extra = nvars - nexps;
	if self:hasmultret(e.k) then
		extra = extra + 1;
		if (extra <= 0) then
			extra = 0;
		end
		luaK:setreturns(fs, e, extra);
		if (extra > 1) then
			luaK:reserveregs(fs, extra - 1);
		end
	else
		if (e.k ~= "VVOID") then
			luaK:exp2nextreg(fs, e);
		end
		if (extra > 0) then
			local reg = fs.freereg;
			luaK:reserveregs(fs, extra);
			luaK:_nil(fs, reg, extra);
		end
	end
end;
luaY.enterlevel = function(self, ls)
	ls.L.nCcalls = ls.L.nCcalls + 1;
	if (ls.L.nCcalls > self.LUAI_MAXCCALLS) then
		luaX:lexerror(ls, "chunk has too many syntax levels", 0);
	end
end;
luaY.leavelevel = function(self, ls)
	ls.L.nCcalls = ls.L.nCcalls - 1;
end;
luaY.enterblock = function(self, fs, bl, isbreakable)
	bl.breaklist = luaK.NO_JUMP;
	bl.isbreakable = isbreakable;
	bl.nactvar = fs.nactvar;
	bl.upval = false;
	bl.previous = fs.bl;
	fs.bl = bl;
	lua_assert(fs.freereg == fs.nactvar);
end;
luaY.leaveblock = function(self, fs)
	local bl = fs.bl;
	fs.bl = bl.previous;
	self:removevars(fs.ls, bl.nactvar);
	if bl.upval then
		luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0);
	end
	lua_assert(not bl.isbreakable or not bl.upval);
	lua_assert(bl.nactvar == fs.nactvar);
	fs.freereg = fs.nactvar;
	luaK:patchtohere(fs, bl.breaklist);
end;
luaY.pushclosure = function(self, ls, func, v)
	local fs = ls.fs;
	local f = fs.f;
	self:growvector(ls.L, f.p, fs.np, f.sizep, nil, luaP.MAXARG_Bx, "constant table overflow");
	f.p[fs.np] = func.f;
	fs.np = fs.np + 1;
	self:init_exp(v, "VRELOCABLE", luaK:codeABx(fs, "OP_CLOSURE", 0, fs.np - 1));
	for i = 0, func.f.nups - 1 do
		local o = ((func.upvalues[i].k == "VLOCAL") and "OP_MOVE") or "OP_GETUPVAL";
		luaK:codeABC(fs, o, 0, func.upvalues[i].info, 0);
	end
end;
luaY.open_func = function(self, ls, fs)
	local L = ls.L;
	local f = self:newproto(ls.L);
	fs.f = f;
	fs.prev = ls.fs;
	fs.ls = ls;
	fs.L = L;
	ls.fs = fs;
	fs.pc = 0;
	fs.lasttarget = -1;
	fs.jpc = luaK.NO_JUMP;
	fs.freereg = 0;
	fs.nk = 0;
	fs.np = 0;
	fs.nlocvars = 0;
	fs.nactvar = 0;
	fs.bl = nil;
	f.source = ls.source;
	f.maxstacksize = 2;
	fs.h = {};
end;
luaY.close_func = function(self, ls)
	local L = ls.L;
	local fs = ls.fs;
	local f = fs.f;
	self:removevars(ls, 0);
	luaK:ret(fs, 0, 0);
	f.sizecode = fs.pc;
	f.sizelineinfo = fs.pc;
	f.sizek = fs.nk;
	f.sizep = fs.np;
	f.sizelocvars = fs.nlocvars;
	f.sizeupvalues = f.nups;
	lua_assert(fs.bl == nil);
	ls.fs = fs.prev;
	if fs then
		self:anchor_token(ls);
	end
end;
luaY.parser = function(self, L, z, buff, name)
	local lexstate = {};
	lexstate.t = {};
	lexstate.lookahead = {};
	local funcstate = {};
	funcstate.upvalues = {};
	funcstate.actvar = {};
	L.nCcalls = 0;
	lexstate.buff = buff;
	luaX:setinput(L, lexstate, z, name);
	self:open_func(lexstate, funcstate);
	funcstate.f.is_vararg = self.VARARG_ISVARARG;
	luaX:next(lexstate);
	self:chunk(lexstate);
	self:check(lexstate, "TK_EOS");
	self:close_func(lexstate);
	lua_assert(funcstate.prev == nil);
	lua_assert(funcstate.f.nups == 0);
	lua_assert(lexstate.fs == nil);
	return funcstate.f;
end;
luaY.field = function(self, ls, v)
	local fs = ls.fs;
	local key = {};
	luaK:exp2anyreg(fs, v);
	luaX:next(ls);
	self:checkname(ls, key);
	luaK:indexed(fs, v, key);
end;
luaY.yindex = function(self, ls, v)
	luaX:next(ls);
	self:expr(ls, v);
	luaK:exp2val(ls.fs, v);
	self:checknext(ls, "]");
end;
luaY.recfield = function(self, ls, cc)
	local fs = ls.fs;
	local reg = ls.fs.freereg;
	local key, val = {}, {};
	if (ls.t.token == "TK_NAME") then
		self:checklimit(fs, cc.nh, self.MAX_INT, "items in a constructor");
		self:checkname(ls, key);
	else
		self:yindex(ls, key);
	end
	cc.nh = cc.nh + 1;
	self:checknext(ls, "=");
	local rkkey = luaK:exp2RK(fs, key);
	self:expr(ls, val);
	luaK:codeABC(fs, "OP_SETTABLE", cc.t.info, rkkey, luaK:exp2RK(fs, val));
	fs.freereg = reg;
end;
luaY.closelistfield = function(self, fs, cc)
	if (cc.v.k == "VVOID") then
		return;
	end
	luaK:exp2nextreg(fs, cc.v);
	cc.v.k = "VVOID";
	if (cc.tostore == luaP.LFIELDS_PER_FLUSH) then
		luaK:setlist(fs, cc.t.info, cc.na, cc.tostore);
		cc.tostore = 0;
	end
end;
luaY.lastlistfield = function(self, fs, cc)
	if (cc.tostore == 0) then
		return;
	end
	if self:hasmultret(cc.v.k) then
		luaK:setmultret(fs, cc.v);
		luaK:setlist(fs, cc.t.info, cc.na, self.LUA_MULTRET);
		cc.na = cc.na - 1;
	else
		if (cc.v.k ~= "VVOID") then
			luaK:exp2nextreg(fs, cc.v);
		end
		luaK:setlist(fs, cc.t.info, cc.na, cc.tostore);
	end
end;
luaY.listfield = function(self, ls, cc)
	self:expr(ls, cc.v);
	self:checklimit(ls.fs, cc.na, self.MAX_INT, "items in a constructor");
	cc.na = cc.na + 1;
	cc.tostore = cc.tostore + 1;
end;
luaY.constructor = function(self, ls, t)
	local fs = ls.fs;
	local line = ls.linenumber;
	local pc = luaK:codeABC(fs, "OP_NEWTABLE", 0, 0, 0);
	local cc = {};
	cc.v = {};
	cc.na, cc.nh, cc.tostore = 0, 0, 0;
	cc.t = t;
	self:init_exp(t, "VRELOCABLE", pc);
	self:init_exp(cc.v, "VVOID", 0);
	luaK:exp2nextreg(ls.fs, t);
	self:checknext(ls, "{");
	repeat
		lua_assert((cc.v.k == "VVOID") or (cc.tostore > 0));
		if (ls.t.token == "}") then
			break;
		end
		self:closelistfield(fs, cc);
		local c = ls.t.token;
		if (c == "TK_NAME") then
			luaX:lookahead(ls);
			if (ls.lookahead.token ~= "=") then
				self:listfield(ls, cc);
			else
				self:recfield(ls, cc);
			end
		elseif (c == "[") then
			self:recfield(ls, cc);
		else
			self:listfield(ls, cc);
		end
	until not self:testnext(ls, ",") and not self:testnext(ls, ";") 
	self:check_match(ls, "}", "{", line);
	self:lastlistfield(fs, cc);
	luaP:SETARG_B(fs.f.code[pc], self:int2fb(cc.na));
	luaP:SETARG_C(fs.f.code[pc], self:int2fb(cc.nh));
end;
luaY.parlist = function(self, ls)
	local fs = ls.fs;
	local f = fs.f;
	local nparams = 0;
	f.is_vararg = 0;
	if (ls.t.token ~= ")") then
		repeat
			local c = ls.t.token;
			if (c == "TK_NAME") then
				self:new_localvar(ls, self:str_checkname(ls), nparams);
				nparams = nparams + 1;
			elseif (c == "TK_DOTS") then
				luaX:next(ls);
				self:new_localvarliteral(ls, "arg", nparams);
				nparams = nparams + 1;
				f.is_vararg = self.VARARG_HASARG + self.VARARG_NEEDSARG;
				f.is_vararg = f.is_vararg + self.VARARG_ISVARARG;
			else
				luaX:syntaxerror(ls, "<name> or " .. self:LUA_QL("...") .. " expected");
			end
		until (f.is_vararg ~= 0) or not self:testnext(ls, ",") 
	end
	self:adjustlocalvars(ls, nparams);
	f.numparams = fs.nactvar - (f.is_vararg % self.HASARG_MASK);
	luaK:reserveregs(fs, fs.nactvar);
end;
luaY.body = function(self, ls, e, needself, line)
	local new_fs = {};
	new_fs.upvalues = {};
	new_fs.actvar = {};
	self:open_func(ls, new_fs);
	new_fs.f.lineDefined = line;
	self:checknext(ls, "(");
	if needself then
		self:new_localvarliteral(ls, "self", 0);
		self:adjustlocalvars(ls, 1);
	end
	self:parlist(ls);
	self:checknext(ls, ")");
	self:chunk(ls);
	new_fs.f.lastlinedefined = ls.linenumber;
	self:check_match(ls, "TK_END", "TK_FUNCTION", line);
	self:close_func(ls);
	self:pushclosure(ls, new_fs, e);
end;
luaY.explist1 = function(self, ls, v)
	local n = 1;
	self:expr(ls, v);
	while self:testnext(ls, ",") do
		luaK:exp2nextreg(ls.fs, v);
		self:expr(ls, v);
		n = n + 1;
	end
	return n;
end;
luaY.funcargs = function(self, ls, f)
	local fs = ls.fs;
	local args = {};
	local nparams;
	local line = ls.linenumber;
	local c = ls.t.token;
	if (c == "(") then
		if (line ~= ls.lastline) then
			luaX:syntaxerror(ls, "ambiguous syntax (function call x new statement)");
		end
		luaX:next(ls);
		if (ls.t.token == ")") then
			args.k = "VVOID";
		else
			self:explist1(ls, args);
			luaK:setmultret(fs, args);
		end
		self:check_match(ls, ")", "(", line);
	elseif (c == "{") then
		self:constructor(ls, args);
	elseif (c == "TK_STRING") then
		self:codestring(ls, args, ls.t.seminfo);
		luaX:next(ls);
	else
		luaX:syntaxerror(ls, "function arguments expected");
		return;
	end
	lua_assert(f.k == "VNONRELOC");
	local base = f.info;
	if self:hasmultret(args.k) then
		nparams = self.LUA_MULTRET;
	else
		if (args.k ~= "VVOID") then
			luaK:exp2nextreg(fs, args);
		end
		nparams = fs.freereg - (base + 1);
	end
	self:init_exp(f, "VCALL", luaK:codeABC(fs, "OP_CALL", base, nparams + 1, 2));
	luaK:fixline(fs, line);
	fs.freereg = base + 1;
end;
luaY.prefixexp = function(self, ls, v)
	local c = ls.t.token;
	if (c == "(") then
		local line = ls.linenumber;
		luaX:next(ls);
		self:expr(ls, v);
		self:check_match(ls, ")", "(", line);
		luaK:dischargevars(ls.fs, v);
	elseif (c == "TK_NAME") then
		self:singlevar(ls, v);
	else
		luaX:syntaxerror(ls, "unexpected symbol");
	end
	return;
end;
luaY.primaryexp = function(self, ls, v)
	local fs = ls.fs;
	self:prefixexp(ls, v);
	while true do
		local c = ls.t.token;
		if (c == ".") then
			self:field(ls, v);
		elseif (c == "[") then
			local key = {};
			luaK:exp2anyreg(fs, v);
			self:yindex(ls, key);
			luaK:indexed(fs, v, key);
		elseif (c == ":") then
			local key = {};
			luaX:next(ls);
			self:checkname(ls, key);
			luaK:_self(fs, v, key);
			self:funcargs(ls, v);
		elseif ((c == "(") or (c == "TK_STRING") or (c == "{")) then
			luaK:exp2nextreg(fs, v);
			self:funcargs(ls, v);
		else
			return;
		end
	end
end;
luaY.simpleexp = function(self, ls, v)
	local c = ls.t.token;
	if (c == "TK_NUMBER") then
		self:init_exp(v, "VKNUM", 0);
		v.nval = ls.t.seminfo;
	elseif (c == "TK_STRING") then
		self:codestring(ls, v, ls.t.seminfo);
	elseif (c == "TK_NIL") then
		self:init_exp(v, "VNIL", 0);
	elseif (c == "TK_TRUE") then
		self:init_exp(v, "VTRUE", 0);
	elseif (c == "TK_FALSE") then
		self:init_exp(v, "VFALSE", 0);
	elseif (c == "TK_DOTS") then
		local fs = ls.fs;
		self:check_condition(ls, fs.f.is_vararg ~= 0, "cannot use " .. self:LUA_QL("...") .. " outside a vararg function");
		local is_vararg = fs.f.is_vararg;
		if (is_vararg >= self.VARARG_NEEDSARG) then
			fs.f.is_vararg = is_vararg - self.VARARG_NEEDSARG;
		end
		self:init_exp(v, "VVARARG", luaK:codeABC(fs, "OP_VARARG", 0, 1, 0));
	elseif (c == "{") then
		self:constructor(ls, v);
		return;
	elseif (c == "TK_FUNCTION") then
		luaX:next(ls);
		self:body(ls, v, false, ls.linenumber);
		return;
	else
		self:primaryexp(ls, v);
		return;
	end
	luaX:next(ls);
end;
luaY.getunopr = function(self, op)
	if (op == "TK_NOT") then
		return "OPR_NOT";
	elseif (op == "-") then
		return "OPR_MINUS";
	elseif (op == "#") then
		return "OPR_LEN";
	else
		return "OPR_NOUNOPR";
	end
end;
luaY.getbinopr_table = {["+"]="OPR_ADD",["-"]="OPR_SUB",["*"]="OPR_MUL",["/"]="OPR_DIV",["%"]="OPR_MOD",["^"]="OPR_POW",TK_CONCAT="OPR_CONCAT",TK_NE="OPR_NE",TK_EQ="OPR_EQ",["<"]="OPR_LT",TK_LE="OPR_LE",[">"]="OPR_GT",TK_GE="OPR_GE",TK_AND="OPR_AND",TK_OR="OPR_OR"};
luaY.getbinopr = function(self, op)
	local opr = self.getbinopr_table[op];
	if opr then
		return opr;
	else
		return "OPR_NOBINOPR";
	end
end;
luaY.priority = {{6,6},{6,6},{7,7},{7,7},{7,7},{10,9},{5,4},{3,3},{3,3},{3,3},{3,3},{3,3},{3,3},{2,2},{1,1}};
luaY.UNARY_PRIORITY = 8;
luaY.subexpr = function(self, ls, v, limit)
	self:enterlevel(ls);
	local uop = self:getunopr(ls.t.token);
	if (uop ~= "OPR_NOUNOPR") then
		luaX:next(ls);
		self:subexpr(ls, v, self.UNARY_PRIORITY);
		luaK:prefix(ls.fs, uop, v);
	else
		self:simpleexp(ls, v);
	end
	local op = self:getbinopr(ls.t.token);
	while (op ~= "OPR_NOBINOPR") and (self.priority[luaK.BinOpr[op] + 1][1] > limit) do
		local v2 = {};
		luaX:next(ls);
		luaK:infix(ls.fs, op, v);
		local nextop = self:subexpr(ls, v2, self.priority[luaK.BinOpr[op] + 1][2]);
		luaK:posfix(ls.fs, op, v, v2);
		op = nextop;
	end
	self:leavelevel(ls);
	return op;
end;
luaY.expr = function(self, ls, v)
	self:subexpr(ls, v, 0);
end;
luaY.block_follow = function(self, token)
	if ((token == "TK_ELSE") or (token == "TK_ELSEIF") or (token == "TK_END") or (token == "TK_UNTIL") or (token == "TK_EOS")) then
		return true;
	else
		return false;
	end
end;
luaY.block = function(self, ls)
	local fs = ls.fs;
	local bl = {};
	self:enterblock(fs, bl, false);
	self:chunk(ls);
	lua_assert(bl.breaklist == luaK.NO_JUMP);
	self:leaveblock(fs);
end;
luaY.check_conflict = function(self, ls, lh, v)
	local fs = ls.fs;
	local extra = fs.freereg;
	local conflict = false;
	while lh do
		if (lh.v.k == "VINDEXED") then
			if (lh.v.info == v.info) then
				conflict = true;
				lh.v.info = extra;
			end
			if (lh.v.aux == v.info) then
				conflict = true;
				lh.v.aux = extra;
			end
		end
		lh = lh.prev;
	end
	if conflict then
		luaK:codeABC(fs, "OP_MOVE", fs.freereg, v.info, 0);
		luaK:reserveregs(fs, 1);
	end
end;
luaY.assignment = function(self, ls, lh, nvars)
	local e = {};
	local c = lh.v.k;
	self:check_condition(ls, (c == "VLOCAL") or (c == "VUPVAL") or (c == "VGLOBAL") or (c == "VINDEXED"), "syntax error");
	if self:testnext(ls, ",") then
		local nv = {};
		nv.v = {};
		nv.prev = lh;
		self:primaryexp(ls, nv.v);
		if (nv.v.k == "VLOCAL") then
			self:check_conflict(ls, lh, nv.v);
		end
		self:checklimit(ls.fs, nvars, self.LUAI_MAXCCALLS - ls.L.nCcalls, "variables in assignment");
		self:assignment(ls, nv, nvars + 1);
	else
		self:checknext(ls, "=");
		local nexps = self:explist1(ls, e);
		if (nexps ~= nvars) then
			self:adjust_assign(ls, nvars, nexps, e);
			if (nexps > nvars) then
				ls.fs.freereg = ls.fs.freereg - (nexps - nvars);
			end
		else
			luaK:setoneret(ls.fs, e);
			luaK:storevar(ls.fs, lh.v, e);
			return;
		end
	end
	self:init_exp(e, "VNONRELOC", ls.fs.freereg - 1);
	luaK:storevar(ls.fs, lh.v, e);
end;
luaY.cond = function(self, ls)
	local v = {};
	self:expr(ls, v);
	if (v.k == "VNIL") then
		v.k = "VFALSE";
	end
	luaK:goiftrue(ls.fs, v);
	return v.f;
end;
luaY.breakstat = function(self, ls)
	local fs = ls.fs;
	local bl = fs.bl;
	local upval = false;
	while bl and not bl.isbreakable do
		if bl.upval then
			upval = true;
		end
		bl = bl.previous;
	end
	if not bl then
		luaX:syntaxerror(ls, "no loop to break");
	end
	if upval then
		luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0);
	end
	bl.breaklist = luaK:concat(fs, bl.breaklist, luaK:jump(fs));
end;
luaY.whilestat = function(self, ls, line)
	local fs = ls.fs;
	local bl = {};
	luaX:next(ls);
	local whileinit = luaK:getlabel(fs);
	local condexit = self:cond(ls);
	self:enterblock(fs, bl, true);
	self:checknext(ls, "TK_DO");
	self:block(ls);
	luaK:patchlist(fs, luaK:jump(fs), whileinit);
	self:check_match(ls, "TK_END", "TK_WHILE", line);
	self:leaveblock(fs);
	luaK:patchtohere(fs, condexit);
end;
luaY.repeatstat = function(self, ls, line)
	local fs = ls.fs;
	local repeat_init = luaK:getlabel(fs);
	local bl1, bl2 = {}, {};
	self:enterblock(fs, bl1, true);
	self:enterblock(fs, bl2, false);
	luaX:next(ls);
	self:chunk(ls);
	self:check_match(ls, "TK_UNTIL", "TK_REPEAT", line);
	local condexit = self:cond(ls);
	if not bl2.upval then
		self:leaveblock(fs);
		luaK:patchlist(ls.fs, condexit, repeat_init);
	else
		self:breakstat(ls);
		luaK:patchtohere(ls.fs, condexit);
		self:leaveblock(fs);
		luaK:patchlist(ls.fs, luaK:jump(fs), repeat_init);
	end
	self:leaveblock(fs);
end;
luaY.exp1 = function(self, ls)
	local e = {};
	self:expr(ls, e);
	local k = e.k;
	luaK:exp2nextreg(ls.fs, e);
	return k;
end;
luaY.forbody = function(self, ls, base, line, nvars, isnum)
	local bl = {};
	local fs = ls.fs;
	self:adjustlocalvars(ls, 3);
	self:checknext(ls, "TK_DO");
	local prep = (isnum and luaK:codeAsBx(fs, "OP_FORPREP", base, luaK.NO_JUMP)) or luaK:jump(fs);
	self:enterblock(fs, bl, false);
	self:adjustlocalvars(ls, nvars);
	luaK:reserveregs(fs, nvars);
	self:block(ls);
	self:leaveblock(fs);
	luaK:patchtohere(fs, prep);
	local endfor = (isnum and luaK:codeAsBx(fs, "OP_FORLOOP", base, luaK.NO_JUMP)) or luaK:codeABC(fs, "OP_TFORLOOP", base, 0, nvars);
	luaK:fixline(fs, line);
	luaK:patchlist(fs, (isnum and endfor) or luaK:jump(fs), prep + 1);
end;
luaY.fornum = function(self, ls, varname, line)
	local fs = ls.fs;
	local base = fs.freereg;
	self:new_localvarliteral(ls, "(for index)", 0);
	self:new_localvarliteral(ls, "(for limit)", 1);
	self:new_localvarliteral(ls, "(for step)", 2);
	self:new_localvar(ls, varname, 3);
	self:checknext(ls, "=");
	self:exp1(ls);
	self:checknext(ls, ",");
	self:exp1(ls);
	if self:testnext(ls, ",") then
		self:exp1(ls);
	else
		luaK:codeABx(fs, "OP_LOADK", fs.freereg, luaK:numberK(fs, 1));
		luaK:reserveregs(fs, 1);
	end
	self:forbody(ls, base, line, 1, true);
end;
luaY.forlist = function(self, ls, indexname)
	local fs = ls.fs;
	local e = {};
	local nvars = 0;
	local base = fs.freereg;
	self:new_localvarliteral(ls, "(for generator)", nvars);
	nvars = nvars + 1;
	self:new_localvarliteral(ls, "(for state)", nvars);
	nvars = nvars + 1;
	self:new_localvarliteral(ls, "(for control)", nvars);
	nvars = nvars + 1;
	self:new_localvar(ls, indexname, nvars);
	nvars = nvars + 1;
	while self:testnext(ls, ",") do
		self:new_localvar(ls, self:str_checkname(ls), nvars);
		nvars = nvars + 1;
	end
	self:checknext(ls, "TK_IN");
	local line = ls.linenumber;
	self:adjust_assign(ls, 3, self:explist1(ls, e), e);
	luaK:checkstack(fs, 3);
	self:forbody(ls, base, line, nvars - 3, false);
end;
luaY.forstat = function(self, ls, line)
	local fs = ls.fs;
	local bl = {};
	self:enterblock(fs, bl, true);
	luaX:next(ls);
	local varname = self:str_checkname(ls);
	local c = ls.t.token;
	if (c == "=") then
		self:fornum(ls, varname, line);
	elseif ((c == ",") or (c == "TK_IN")) then
		self:forlist(ls, varname);
	else
		luaX:syntaxerror(ls, self:LUA_QL("=") .. " or " .. self:LUA_QL("in") .. " expected");
	end
	self:check_match(ls, "TK_END", "TK_FOR", line);
	self:leaveblock(fs);
end;
luaY.test_then_block = function(self, ls)
	luaX:next(ls);
	local condexit = self:cond(ls);
	self:checknext(ls, "TK_THEN");
	self:block(ls);
	return condexit;
end;
luaY.ifstat = function(self, ls, line)
	local fs = ls.fs;
	local escapelist = luaK.NO_JUMP;
	local flist = self:test_then_block(ls);
	while ls.t.token == "TK_ELSEIF" do
		escapelist = luaK:concat(fs, escapelist, luaK:jump(fs));
		luaK:patchtohere(fs, flist);
		flist = self:test_then_block(ls);
	end
	if (ls.t.token == "TK_ELSE") then
		escapelist = luaK:concat(fs, escapelist, luaK:jump(fs));
		luaK:patchtohere(fs, flist);
		luaX:next(ls);
		self:block(ls);
	else
		escapelist = luaK:concat(fs, escapelist, flist);
	end
	luaK:patchtohere(fs, escapelist);
	self:check_match(ls, "TK_END", "TK_IF", line);
end;
luaY.localfunc = function(self, ls)
	local v, b = {}, {};
	local fs = ls.fs;
	self:new_localvar(ls, self:str_checkname(ls), 0);
	self:init_exp(v, "VLOCAL", fs.freereg);
	luaK:reserveregs(fs, 1);
	self:adjustlocalvars(ls, 1);
	self:body(ls, b, false, ls.linenumber);
	luaK:storevar(fs, v, b);
	self:getlocvar(fs, fs.nactvar - 1).startpc = fs.pc;
end;
luaY.localstat = function(self, ls)
	local nvars = 0;
	local nexps;
	local e = {};
	repeat
		self:new_localvar(ls, self:str_checkname(ls), nvars);
		nvars = nvars + 1;
	until not self:testnext(ls, ",") 
	if self:testnext(ls, "=") then
		nexps = self:explist1(ls, e);
	else
		e.k = "VVOID";
		nexps = 0;
	end
	self:adjust_assign(ls, nvars, nexps, e);
	self:adjustlocalvars(ls, nvars);
end;
luaY.funcname = function(self, ls, v)
	local needself = false;
	self:singlevar(ls, v);
	while ls.t.token == "." do
		self:field(ls, v);
	end
	if (ls.t.token == ":") then
		needself = true;
		self:field(ls, v);
	end
	return needself;
end;
luaY.funcstat = function(self, ls, line)
	local v, b = {}, {};
	luaX:next(ls);
	local needself = self:funcname(ls, v);
	self:body(ls, b, needself, line);
	luaK:storevar(ls.fs, v, b);
	luaK:fixline(ls.fs, line);
end;
luaY.exprstat = function(self, ls)
	local fs = ls.fs;
	local v = {};
	v.v = {};
	self:primaryexp(ls, v.v);
	if (v.v.k == "VCALL") then
		luaP:SETARG_C(luaK:getcode(fs, v.v), 1);
	else
		v.prev = nil;
		self:assignment(ls, v, 1);
	end
end;
luaY.retstat = function(self, ls)
	local fs = ls.fs;
	local e = {};
	local first, nret;
	luaX:next(ls);
	if (self:block_follow(ls.t.token) or (ls.t.token == ";")) then
		first, nret = 0, 0;
	else
		nret = self:explist1(ls, e);
		if self:hasmultret(e.k) then
			luaK:setmultret(fs, e);
			if ((e.k == "VCALL") and (nret == 1)) then
				luaP:SET_OPCODE(luaK:getcode(fs, e), "OP_TAILCALL");
				lua_assert(luaP:GETARG_A(luaK:getcode(fs, e)) == fs.nactvar);
			end
			first = fs.nactvar;
			nret = self.LUA_MULTRET;
		elseif (nret == 1) then
			first = luaK:exp2anyreg(fs, e);
		else
			luaK:exp2nextreg(fs, e);
			first = fs.nactvar;
			lua_assert(nret == (fs.freereg - first));
		end
	end
	luaK:ret(fs, first, nret);
end;
luaY.statement = function(self, ls)
	local line = ls.linenumber;
	local c = ls.t.token;
	if (c == "TK_IF") then
		self:ifstat(ls, line);
		return false;
	elseif (c == "TK_WHILE") then
		self:whilestat(ls, line);
		return false;
	elseif (c == "TK_DO") then
		luaX:next(ls);
		self:block(ls);
		self:check_match(ls, "TK_END", "TK_DO", line);
		return false;
	elseif (c == "TK_FOR") then
		self:forstat(ls, line);
		return false;
	elseif (c == "TK_REPEAT") then
		self:repeatstat(ls, line);
		return false;
	elseif (c == "TK_FUNCTION") then
		self:funcstat(ls, line);
		return false;
	elseif (c == "TK_LOCAL") then
		luaX:next(ls);
		if self:testnext(ls, "TK_FUNCTION") then
			self:localfunc(ls);
		else
			self:localstat(ls);
		end
		return false;
	elseif (c == "TK_RETURN") then
		self:retstat(ls);
		return true;
	elseif (c == "TK_BREAK") then
		luaX:next(ls);
		self:breakstat(ls);
		return true;
	else
		self:exprstat(ls);
		return false;
	end
end;
luaY.chunk = function(self, ls)
	local islast = false;
	self:enterlevel(ls);
	while not islast and not self:block_follow(ls.t.token) do
		islast = self:statement(ls);
		self:testnext(ls, ";");
		lua_assert((ls.fs.f.maxstacksize >= ls.fs.freereg) and (ls.fs.freereg >= ls.fs.nactvar));
		ls.fs.freereg = ls.fs.nactvar;
	end
	self:leavelevel(ls);
end;

return newLoadstring]]></ProtectedString>
			<int64 name="SourceAssetId">14558025645</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
</roblox>